<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>找试卷</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-26T05:57:16.175Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zhaoShijuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>electron学习</title>
    <link href="http://yoursite.com/2018/11/26/electron%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/11/26/electron学习/</id>
    <published>2018-11-26T05:53:43.000Z</published>
    <updated>2018-11-26T05:57:16.175Z</updated>
    
    <content type="html"><![CDATA[<ol><li>使用vue-electron脚手架时，electron-builder与electron-packager的区别（参考文档：<a href="https://github.com/ielectron-userland/electron-builder与https://github.com/ielectron-userland/electron-packager）" target="_blank" rel="noopener">https://github.com/ielectron-userland/electron-builder与https://github.com/ielectron-userland/electron-packager）</a></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;使用vue-electron脚手架时，electron-builder与electron-packager的区别（参考文档：&lt;a href=&quot;https://github.com/ielectron-userland/electron-builder与https
      
    
    </summary>
    
      <category term="Electron" scheme="http://yoursite.com/categories/Electron/"/>
    
    
  </entry>
  
  <entry>
    <title>XHR对象</title>
    <link href="http://yoursite.com/2018/11/06/XHR%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/11/06/XHR对象/</id>
    <published>2018-11-06T09:55:10.000Z</published>
    <updated>2018-11-26T05:54:32.258Z</updated>
    
    <content type="html"><![CDATA[<p>XHR其实就是XMLHttpRequest对象，也就是Ajax的核心技术。XHR为向服务器发送请求以及解析服务器响应提供了接口，能够以异步的方式从服务器获取信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;XHR其实就是XMLHttpRequest对象，也就是Ajax的核心技术。XHR为向服务器发送请求以及解析服务器响应提供了接口，能够以异步的方式从服务器获取信息。&lt;/p&gt;

      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>客户端数据存储</title>
    <link href="http://yoursite.com/2018/10/29/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    <id>http://yoursite.com/2018/10/29/客户端数据存储/</id>
    <published>2018-10-29T11:35:32.000Z</published>
    <updated>2018-10-31T09:38:36.134Z</updated>
    
    <content type="html"><![CDATA[<p>常见的客户端数据存储：Cookie，Web Storage。其中Web Storage主要包含localStorage，sessionStorage，globalStorage这三种，Web Storage规范出现主要是为了提供一种除了cookie之外的会话存储的途径，以及一种可以存储大量可以跨会话存在的数据的机制。Cookie也叫做HTTP Cookie，最初在客户端是用于存储会话信息的。👓👌咳咳，接下来，我们深入的了解一下Cookie以及Web Storage吧～～～<br><a id="more"></a></p><h4 id="1-Cookie"><a href="#1-Cookie" class="headerlink" title="1. Cookie"></a>1. Cookie</h4><p>Cookie也就是HTTP Cookie，最初在客户端用于存储会话信息，设置完cookie后，在指定的域地址中，请求中带有cookie的信息（Request Headers中就会包含cookie），cookie的名和值在传送时是需要通过URL编码，否则会乱码。<br>该标准要求服务器对 任意 HTTP 请求发送 Set-Cookie HTTP 头作为响应的一部分，其中包含会话信息。浏览器会存储这样的会话信息，并在这之后，通过为每个请求添加 Cookie HTTP 头将信息发送回服务器。</p><h5 id="1-1-限制"><a href="#1-1-限制" class="headerlink" title="1.1 限制"></a>1.1 限制</h5><p>访问限制：在某个环境下设置了cookie，那么此cookie是绑定在此特定的域名下，以后再给创建它的域名发送请求时，都会包含这个cookie。这个让cookie只能在创建它的域名下被访问，其它环境不可以进行访问。<br>个数限制：不同浏览器下，每个域中所能包含的cookie个数也是有限的。当单个域名下的cookie数量超出限制后，浏览器会删除以前设置的cookie，但是IE与Opera会删除最少使用的cookie，FireFox是随机删除。<br>长度限制：cookie长度，在大多数浏览器下，大约是4096B的长度限制。这个长度限制是对每个域下的所有的cookie的总限制，而不是单个cookie的长度限制。超出长度限制，则浏览器会默默地将cookie丢掉。</p><h5 id="1-2-cookie构成"><a href="#1-2-cookie构成" class="headerlink" title="1.2 cookie构成"></a>1.2 cookie构成</h5><ol><li>名称name： cookie名称不区分大小写，相同字母，大小写不一样的，会被当成一个cookie。在实际中，最好定义以及后面使用的时候，要相同大小写相同字母，因为有些浏览器中cookie键值对需要进行URL编码。</li><li>值value： 对应cookie名称的值，是字符串，需要通过URL编码。</li><li>域domain： cookie的域限制，指定cookie在哪个域下被访问。</li><li>地址path： 指定域中的哪个路径，应该向服务器端发送cookie</li><li>失效时间expires： cookie被删除的时间戳。到达结束时间的时候，cookie会被删除。这个值要是GMT格式的日期(Wdy, DD-Mon-YYYY HH:MM:SS GMT)，如果设置的时间是在当前日期之前，则cookie会立马被删除。</li><li>安全标志secure： 指定之后，cookie只有在SSL连接的时候才能发送到服务器（也就是https中只能在https的域中，不能发送给同域名的http中）。是一个非键值对，就一个单独的secure单词标志。</li></ol><h5 id="1-3-cookie的操作"><a href="#1-3-cookie的操作" class="headerlink" title="1.3 cookie的操作"></a>1.3 cookie的操作</h5><p>在浏览器中，cookie是挂载在document上的。<br><strong>获取</strong>： 通过document.cookie来获取当前页面可用的cookie字符串（一个使用分号连接起来的键值对字符串），并且得到的所有的键值对都是经过URL编码的，所以需要通过decodeURIComponent来解码<br><strong>设置</strong>： document.cookie可以设置一个新的cookie字符串，这个cookie字符串会被解析并添加到现有的cookie集合中。设置document.cookie并不会覆盖掉原来的cookie，而是在原先的基础上添加（只有在设置的cookie名相同，则会覆盖掉原先设置的同名cookie的值）。在设置时，最好每次对键值对都进行一次encodeURIComponent编码，防止中文乱码情况<br><strong>删除</strong>：没有直接删除的方法，但是可以通过将有效时间设置成现在之前的时间，从而使得cookie删除</p><pre><code>const COOKIE_UTIL = {    get: (name) =&gt; {        var cookieName = encodeURIComponent(name) + &apos;=&apos;,             cookieStart = document.cookie.indexOf(cookieName),             cookieValue = &apos;&apos;;        if (cookieStart &gt; -1) {            var cookieEnd = document.cookie.indexOf(&apos;;&apos;, cookieStart);            cookieEnd = cookieEnd === -1 ? document.cookie.length : cookieEnd;            cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));        }        return cookieValue;         },    set: (name, value, expires, path, domain, secure) =&gt; {        var cookieText = encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value);        if (expires instanceof Date) {            cookieText += &apos;; expires=&apos; + expires.toGMTString();        }        if (path) {            cookieText += &apos;; path=&apos; + path;        }        if (domain) {            cookieText += &apos;; domain=&apos; + domain;        }        if (secure) {            cookieText += &apos;;secure&apos;;            }        document.cookie = cookieText;    },    unset: (name, path, domain, secure) =&gt; {        this.set(name, &quot;&quot;, new Date(0), path, domain, secure);    }};</code></pre><h4 id="2-Web-Storage"><a href="#2-Web-Storage" class="headerlink" title="2. Web Storage"></a>2. Web Storage</h4><p>Web Storage是一个标准，包含了sessionStorage，localStorage，globalStorage对象，都是直接挂载于window对象上的。</p><h5 id="2-1-Storage类型"><a href="#2-1-Storage类型" class="headerlink" title="2.1 Storage类型"></a>2.1 Storage类型</h5><p>Storage实例有如下几个方法：<br><strong>1. 增</strong> getItem(name) 指定名称name获取对应的值；key(index) 获取index处的名称<br><strong>2. 删</strong> clear() 删除所有的值； 直接使用对象的删除 delete<br><strong>3. 改</strong> setItem(name, value) 为指定name设置一个对应的值<br><strong>4. 查</strong> getItem(name) 获取指定name的值<br>属性：length ==&gt; Storage实例中含有几对键值对</p><h5 id="2-2-sessionStorage对象"><a href="#2-2-sessionStorage对象" class="headerlink" title="2.2 sessionStorage对象"></a>2.2 sessionStorage对象</h5><p>sessionStorage是用于特定会话中存储数据，并且数据只保留到<span class="font-color-red">浏览器关闭</span>。存储在 sessionStorage 中的数据只能由最初给对象存储数据的页面访问到，所以对多页面应用有限制。Storage实例含有的方法和属性，sessionStorage也拥有。<br><strong>范围限制</strong>：要访问同一个localStorage，需要在同一协议，同一域名，同一端口号的页面。<br><strong>存储时间</strong>：一直保留到浏览器关闭。</p><h5 id="2-3-localStorage对象"><a href="#2-3-localStorage对象" class="headerlink" title="2.3 localStorage对象"></a>2.3 localStorage对象</h5><p>localStorage是在修订后的HTML5规范中取代了globalStorage。localStorage是Storage实例，因此拥有Storage类型的所有方法以及属性。<br><strong>范围限制</strong>：要访问同一个localStorage，需要在同一协议，同一域名，同一端口号的页面。<br><strong>存储时间</strong>：一直保留到主动使用方法删除或者用户清除浏览器缓存。</p><h5 id="2-4-globalStorage对象"><a href="#2-4-globalStorage对象" class="headerlink" title="2.4 globalStorage对象"></a>2.4 globalStorage对象</h5><p>globalStorage主要目的是为了跨域会话，但是也有特定的限制。在使用globalStorage，首先要指定哪些区域可以访问该数据，可以通过方括号标记使用属性来实现。<br>eg: globalStorage[‘my.com’].name = ‘zhaoshijuan’<br>这里访问的globalStorage[‘my.com’]是针对域名‘my.com’的存储空间<br>⚠️ globalStorage不是Storage实例，而上面的globalStorage[‘my.com’]才是Storage对象，因此拥有Storage上的方法以及属性的是globalStorage[‘my.com’]这个对象。<br>globalStorage[‘’].name = ‘zhaoshijuan’，这个设置是对任何人都看见，没有域限制。<br>globalStorage[‘net’].name = ‘zhaoshijuan’，这个设置会让所有以.net结束的域名访问。<br>在不确定域名时，可以通过这样设置：globalStorage[‘location.host’].name = ‘zhaoshijuan’<br><strong>范围限制</strong>：根据globalStorage后[]括号而定。<br><strong>存储时间</strong>：如果没有使用removeItem或者delete删除，会一直保留到用户删除浏览器缓存为止。</p><blockquote><p>Stroge对象中存储的都是字符串</p></blockquote><h5 id="2-5-Storage事件"><a href="#2-5-Storage事件" class="headerlink" title="2.5 Storage事件"></a>2.5 Storage事件</h5><p>对Storage对象进行的修改，都会触发storage事件，storage事件是绑定在document上的。storage事件event对象含有如下几个属性：<br>domain：发生变化的存储空间的域名<br>key：变化的键名<br>newValue：修改值，则是新值；删除值，则是undefined<br>oldValue：键对应值被修改之前的值</p><p>addEventListener(document, ‘storage’, function(event) {})</p><h4 id="3-Cookie与Web-Storage对比"><a href="#3-Cookie与Web-Storage对比" class="headerlink" title="3. Cookie与Web Storage对比"></a>3. Cookie与Web Storage对比</h4><h5 id="3-1-区别"><a href="#3-1-区别" class="headerlink" title="3.1 区别"></a>3.1 区别</h5><ol><li>存储内容是否发送到服务器端：当设置了Cookie后，数据会发送到服务器端，造成一定的宽带浪费； web storage,会将数据保存到本地，不会造成宽带浪费；</li><li>数据存储大小不同：Cookie数据不能超过4K,适用于会话标识；web storage数据存储可以达到5M;</li><li>数据存储的有效期限不同：cookie只在设置了Cookid过期时间之前一直有效，即使关闭窗口或者浏览器；sessionStorage,仅在关闭浏览器之前有效；localStorage,数据存储永久有效；</li><li>作用域不同：cookie和localStorage是在同源同窗口中都是共享的；sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；</li></ol><h5 id="3-2-Web-Storage相比Cookie的优势"><a href="#3-2-Web-Storage相比Cookie的优势" class="headerlink" title="3.2 Web Storage相比Cookie的优势"></a>3.2 Web Storage相比Cookie的优势</h5><ol><li>存储空间更大：IE8下每个独立的存储空间为10M，其他浏览器实现略有不同，但都比Cookie要大很多。</li><li>存储内容不会发送到服务器：当设置了Cookie后，Cookie的内容会随着请求一并发送的服务器，这对于本地存储的数据是一种带宽浪费。而Web Storage中的数据则仅仅是存在本地，不会与服务器发生任何交互。</li><li>更多丰富易用的接口：Web Storage提供了一套更为丰富的接口，如setItem,getItem,removeItem,clear等,使得数据操作更为简便。cookie需要自己封装。</li><li>独立的存储空间：每个域（包括子域）有独立的存储空间，各个存储空间是完全独立的，因此不会造成数据混乱。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的客户端数据存储：Cookie，Web Storage。其中Web Storage主要包含localStorage，sessionStorage，globalStorage这三种，Web Storage规范出现主要是为了提供一种除了cookie之外的会话存储的途径，以及一种可以存储大量可以跨会话存在的数据的机制。Cookie也叫做HTTP Cookie，最初在客户端是用于存储会话信息的。👓👌咳咳，接下来，我们深入的了解一下Cookie以及Web Storage吧～～～&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>Function对象</title>
    <link href="http://yoursite.com/2018/10/26/Function%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/10/26/Function对象/</id>
    <published>2018-10-26T06:18:11.000Z</published>
    <updated>2018-10-29T09:44:33.098Z</updated>
    
    <content type="html"><![CDATA[<p>每次看源码或者找一些求最大值最小值简便方法时，就会遇见call(),apply()这两个方法，当时的理解就是：设置函数上下文，this指向。但是……理解得太片面了，正好有时间，就打算了解一下👏👏👏<br><a id="more"></a></p><h4 id="1-Function类型"><a href="#1-Function类型" class="headerlink" title="1. Function类型"></a>1. Function类型</h4><p>我们先了解一波Function这种引用类型吧～～～</p><h5 id="1-1-函数定义"><a href="#1-1-函数定义" class="headerlink" title="1.1 函数定义"></a>1.1 函数定义</h5><p>「1」函数声明语法 function fun () {}<br>「2」函数表达式定义  var fun = function () {}<br>「3」Function构造函数  var fun = new Function (‘params1’, ‘params2’, ‘return params1 + prams2’)</p><blockquote><p>不推荐使用Function构造函数定义，因为会导致两次解析：第一次是解析常规的js代码，第二次是解析传入构造函数中的字符串</p></blockquote><h6 id="1-2-函数内部的一些属性"><a href="#1-2-函数内部的一些属性" class="headerlink" title="1.2 函数内部的一些属性"></a>1.2 函数内部的一些属性</h6><p>每个函数内部都可以使用arguments来访问传入的所有的参数（是一个伪数组）；<br>arguments.callee是一个指针，指向拥有这个arguments对象的函数；<br>caller是函数对象的属性，保存着调用此函数的函数引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var inner = function() &#123; </span><br><span class="line">console.log(inner.caller); // outer</span><br><span class="line">// 等价于下面</span><br><span class="line">console.log(arguments.callee.caller)</span><br><span class="line">&#125;;</span><br><span class="line">var outer = function() &#123;</span><br><span class="line">inner();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果某函数在全局作用域下调用的话，则某函数的caller为null</p><h5 id="1-3-函数属性"><a href="#1-3-函数属性" class="headerlink" title="1.3 函数属性"></a>1.3 函数属性</h5><p>「1」长度length：表示的函数接受的命名参数的个数<br>「2」原型prototype：不可枚举，保存了所有实例方法</p><h4 id="2-函数内部非继承方法：apply，call，bind"><a href="#2-函数内部非继承方法：apply，call，bind" class="headerlink" title="2. 函数内部非继承方法：apply，call，bind"></a>2. 函数内部非继承方法：apply，call，bind</h4><p>apply，call，bind三个方法都是指定在特定作用域内调用此函数，实际上相当于设置了此函数内的this对象的值</p><h5 id="2-1-apply"><a href="#2-1-apply" class="headerlink" title="2.1 apply"></a>2.1 apply</h5><p>apply（作用域，数组类型参数）<br>两个参数：一个在其中运行的函数的作用域，一个是参数数组（arguments或者Array实例）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function sum (num1, num2) &#123;</span><br><span class="line">return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">function applySum (num1, num2) &#123;</span><br><span class="line">return sum.apply(this, arguments);</span><br><span class="line">&#125;</span><br><span class="line">function applySum1 (num1, num2) &#123;</span><br><span class="line">return sum.apply(this, [num1, num2]);</span><br><span class="line">&#125;</span><br><span class="line">applySum(10, 10); // 20</span><br><span class="line">applySum1(10, 10); // 20</span><br></pre></td></tr></table></figure><h5 id="2-2-call"><a href="#2-2-call" class="headerlink" title="2.2 call"></a>2.2 call</h5><p>call（作用域，参数1，参数2，……，参数N）<br>两类参数：一类也就是第一个参数在其中运行的函数的作用域；另一类也就是参数，是直接传递给函数的参数，传递给函数的参数必须逐一列举出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sum (num1, num2) &#123;</span><br><span class="line">return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">function callSum (num1, num2) &#123;</span><br><span class="line">return sum.call(this, num1, num2)</span><br><span class="line">&#125;</span><br><span class="line">callSum(10 ,10)// 20</span><br></pre></td></tr></table></figure><h5 id="2-3-bind-IE9"><a href="#2-3-bind-IE9" class="headerlink" title="2.3 bind   IE9+"></a>2.3 bind   <span class="font-color-red">IE9+</span></h5><p>bind()这个方法会创建一个函数的实例，其this的值会被绑定到传给bind()函数的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.color = &apos;red&apos;;</span><br><span class="line">var object = &#123; color: &apos;blue&apos; &#125;;</span><br><span class="line">function getColor () &#123;</span><br><span class="line">return this.color;</span><br><span class="line">&#125;</span><br><span class="line">var getColor1 = getColor.bind(object);</span><br><span class="line">getColor1(); // blue</span><br></pre></td></tr></table></figure><h5 id="2-4-apply、call、bind区别"><a href="#2-4-apply、call、bind区别" class="headerlink" title="2.4 apply、call、bind区别"></a>2.4 apply、call、bind区别</h5><p>call,apply,bind作用：扩大了函数赖以运行的作用域。<br>对于call，apply的第一个参数如果指定成null或者undefined的时候，则此时的this就会指向全局环境。</p><p>「1」call，apply区别主要在于传参，除了指定作用域的参数外，call的其他参数主要是直接传递给函数的参数，需要一一列举；而apply的其他参数是一个参数数组（arguments或者Array实例）。其实就是参数格式不一样。<br>「2」bind与call，apply的区别主要是call，apply不会生成一个函数，而是直接传递作用域；而bind则是使用传入的作用域绑定this创建一个函数的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1, 2, 3, 4, 5, 6, 7];</span><br><span class="line">var max1 = Math.max.apply(null, numbers);</span><br><span class="line">// 等价于下面</span><br><span class="line">var max2 = Math.max.call(null, ...numbers);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每次看源码或者找一些求最大值最小值简便方法时，就会遇见call(),apply()这两个方法，当时的理解就是：设置函数上下文，this指向。但是……理解得太片面了，正好有时间，就打算了解一下👏👏👏&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>Array数组之旅</title>
    <link href="http://yoursite.com/2018/10/23/Array%E6%95%B0%E7%BB%84%E4%B9%8B%E6%97%85/"/>
    <id>http://yoursite.com/2018/10/23/Array数组之旅/</id>
    <published>2018-10-23T07:01:41.000Z</published>
    <updated>2018-10-31T09:55:10.166Z</updated>
    
    <content type="html"><![CDATA[<p>要学习ES6中的数组扩展篇章，所以就先去预习了一波原本接触到的Array。所谓温故而知新嘛~~<br>首先我们先了解一下js中的对象：1.内部对象，内部对象包含下面三种：错误对象（标识错误），内置对象（不需要使用new操作符来进行初始化，Math与JSON两种），常用对象（8种，String、Number、Date、Function、Boolean、Array、Object、RegExp）；2.宿主对象，宿主对象主要有两个window与document。3.自定义对象，除了内部对象以及宿主对象之外，其它都为自定义对象，也就是开发者自己定义的对象。<br>说起Array，能想到的就是属性length，方法push，pop，reverse，shift，unshift，jion，slice，splice……等方法<br>推荐喜马拉雅上的「陪你读书（JavaScript WEB 编程）」的课程~~~<br><a id="more"></a></p><p>基础数据类型：Number、undefined、null、Boolean、String、symbol<br>复杂类型：Object<br>typeOf(null) === ‘Object’<br>js解释器，会将其进行解释，转化成二进制，默认前三位是0的就是Object类型。而null转化成二进制的时候，会变成所有位置上全是0。</p><h3 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a>Array数组</h3><p>是一个有序的合集。对象是无序的合集，对于有序的对象称作为数组。数组里面可以包含任何数据类型，数组大小可以调整。</p><h4 id="1-创建数组"><a href="#1-创建数组" class="headerlink" title="1. 创建数组"></a>1. 创建数组</h4><p>new关键字 new Array(参数),其中参数只是一个数字的话，则创建出来的是一个指定长度的数组，里面的每项都是undefined。不要使用多个逗号进行创建数组<br>字面量    [array1, array2]</p><h4 id="2-方法"><a href="#2-方法" class="headerlink" title="2. 方法"></a>2. 方法</h4><h5 id="2-1-读写"><a href="#2-1-读写" class="headerlink" title="2.1 读写"></a>2.1 读写</h5><p>读取arr[index]；写arr[index] = 1；<br>删除delete arr[index],数组长度不会变化，但是在index位置上的数据就是undefined</p><h5 id="2-2-判断是否是数组类型"><a href="#2-2-判断是否是数组类型" class="headerlink" title="2.2 判断是否是数组类型"></a>2.2 判断是否是数组类型</h5><ol><li>instanceof  arr instanceof Array</li><li>原型构造函数 arr.<strong> proto </strong>.constructor === Array</li><li>Object.prototype.toString.call(arr) == ‘[object Array]’</li><li>ES6中的isArray方法  Array.isArray(arr)</li></ol><h5 id="2-3-变异方法"><a href="#2-3-变异方法" class="headerlink" title="2.3 变异方法"></a>2.3 变异方法</h5><p>变异方法，在Vue中包含，它们会触发视图更新<br>栈方法：push,pop在数组的末端进行添加或者删除，返回值push是数组的长度pop是弹出的那一项，对数组造成影响<br>队列方法：unshift,shift在数组的首端进行添加或者删除，返回值unshift是数组的长度shift是弹出的那一项，对数组造成影响<br>排序：sort 按照字符串的ASII码进行排序。（fn(a,b){}）按照fn方法排序，a-b从小到大，b-a从大到小<br>反转：reverse<br>删除，截取，替换：splice(index,num,item) index是添加/删除的位置，负数就是从后往前；num是删除的数量；item是在index位置上添加的新内容</p><h5 id="2-4-非变异方法"><a href="#2-4-非变异方法" class="headerlink" title="2.4 非变异方法"></a>2.4 非变异方法</h5><p>对于非变异的，则不会触发视图更新，需要使用vm.$set或者Vue.set方法<br>截取：slice（start,end）返回的是从start开始，end结束的截取的子数组。start，end可以为负数，表示从数组末端到开始。start，end都没有，则截取整个数组；只有start，从start开始到结束截取；有start，end，截取start至end。<br>转为字符串：join(separator) 将数组转化为字符串，中间使用separator分隔开。<br>连接数组：concat(arr1,……,arrn) 连接两个或者多个数组，返回的是一个数组。</p><blockquote><p>扩展：push与concat的区别，同样：都是连接作用。不同：push会影响数组，concat不影响；如果参数是一个数组，push只会增加一项，直接将数组作为它最新的一项，会变成一个二维数组，concat的话，直接将数组一个一个的添加到原来的数组上，还是一个一维数组。</p></blockquote><h5 id="2-5-ES5的indexOf与lastIndexOf"><a href="#2-5-ES5的indexOf与lastIndexOf" class="headerlink" title="2.5 ES5的indexOf与lastIndexOf"></a>2.5 ES5的indexOf与lastIndexOf</h5><p>arr.indexOf(item) 返回item在arr数组中从左到右的index，有返回index，没有返回-1<br>arr.lastIndexOf(item) 返回item在arr数组中从右到左的index，有返回index，没有返回-1</p><h5 id="2-6-其它一些不常用常见的方法"><a href="#2-6-其它一些不常用常见的方法" class="headerlink" title="2.6 其它一些不常用常见的方法"></a>2.6 其它一些不常用常见的方法</h5><ol><li>every</li><li>fill</li><li>filter</li><li>forEach</li><li>Map</li><li>reduce</li><li>reduceRight</li></ol><h4 id="3-ES6-数组扩展"><a href="#3-ES6-数组扩展" class="headerlink" title="3. ES6 数组扩展"></a>3. ES6 数组扩展</h4><h5 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h5><h4 id="4-数组应用"><a href="#4-数组应用" class="headerlink" title="4. 数组应用"></a>4. 数组应用</h4><h5 id="4-1-数组去重"><a href="#4-1-数组去重" class="headerlink" title="4.1 数组去重"></a>4.1 数组去重</h5><p>方法一：循环去重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法二：ES6中的set数据类型<br>Set它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const set = new Set([1, 2, 3, 4, 4]);</span><br><span class="line">[...set]或者new Array(...set) // [1,2,3,4]</span><br></pre></td></tr></table></figure><p>方法三：数组存放，indexOf判断<br>遍历新数组，不存在就push进新数组中，存在就跳过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.unique = function() &#123;</span><br><span class="line">    var n = []; // 存放已遍历的满足条件的元素</span><br><span class="line">    for (var i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">        // indexOf()判断当前元素是否已存在</span><br><span class="line">        if (n.indexOf(this[i]) == -1) &#123;</span><br><span class="line">        n.push(this[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法四：对象存放，哈希算法(映射)判断<br>遍历新数组，不存在就push进新数组中，存在就跳过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.unique = function() &#123;</span><br><span class="line">    // n为hash表，r为临时数组</span><br><span class="line">    var n = &#123;&#125;, r = [];</span><br><span class="line">    for (var i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">        // 如果hash表中没有当前项</span><br><span class="line">        if (!n[this[i]]) &#123;</span><br><span class="line">            // 存入hash表</span><br><span class="line">            n[this[i]] = true;</span><br><span class="line">            // 把当前数组的当前项push到临时数组里面</span><br><span class="line">            r.push(this[i]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法五：现排序，后比较</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.unique = function() &#123;</span><br><span class="line">    this.sort();</span><br><span class="line">    var re = [this[0]];</span><br><span class="line">    for (var i = 1; i &lt; this.length; i++) &#123;</span><br><span class="line">        if (this[i] !== re[re.length - 1]) &#123;</span><br><span class="line">            re.push(this[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-数组拍平"><a href="#4-2-数组拍平" class="headerlink" title="4.2 数组拍平"></a>4.2 数组拍平</h5><p>方法一：只适合二维数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.concat.apply([],arr)</span><br></pre></td></tr></table></figure><p>方法二：ES6的Generator函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, [[2, 3], 4], [5, 6]];</span><br><span class="line">var arrCopy = [];</span><br><span class="line"></span><br><span class="line">var flat = function* (a) &#123;</span><br><span class="line">  var length = a.length;</span><br><span class="line">  for (var i = 0; i &lt; length; i++) &#123;</span><br><span class="line">    var item = a[i];</span><br><span class="line">    if (Object.prototype.toString.call(item) == &apos;[object Array]&apos;) &#123;</span><br><span class="line">      yield* flat(item);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      yield item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for (var f of flat(arr)) &#123;</span><br><span class="line">  arrCopy.push(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要学习ES6中的数组扩展篇章，所以就先去预习了一波原本接触到的Array。所谓温故而知新嘛~~&lt;br&gt;首先我们先了解一下js中的对象：1.内部对象，内部对象包含下面三种：错误对象（标识错误），内置对象（不需要使用new操作符来进行初始化，Math与JSON两种），常用对象（8种，String、Number、Date、Function、Boolean、Array、Object、RegExp）；2.宿主对象，宿主对象主要有两个window与document。3.自定义对象，除了内部对象以及宿主对象之外，其它都为自定义对象，也就是开发者自己定义的对象。&lt;br&gt;说起Array，能想到的就是属性length，方法push，pop，reverse，shift，unshift，jion，slice，splice……等方法&lt;br&gt;推荐喜马拉雅上的「陪你读书（JavaScript WEB 编程）」的课程~~~&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>vue源码分析-组件化</title>
    <link href="http://yoursite.com/2018/10/15/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    <id>http://yoursite.com/2018/10/15/vue源码分析-组件化/</id>
    <published>2018-10-15T13:39:06.000Z</published>
    <updated>2018-10-29T09:44:17.620Z</updated>
    
    <content type="html"><![CDATA[<p>终于弄懂了定义一个vue实例到渲染成页面DOM的整个过程，心情炒鸡棒，今天打算开始了解一下vue的另外一个核心思想 — <strong>组件化</strong>。<br>所谓组件化，也就是将页面根据一些规则（业务/逻辑等）划分成一个个组件（Component），每个组件的css,js,模版,图片等资源都相互独立，每个组件的资源都放在一起开发维护。这样便于维护以及实现可复用～～～<br><a id="more"></a></p><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p><span class="text-important">组件的 vnode 是没有 children 的</span></p><h4 id="1-createComponent"><a href="#1-createComponent" class="headerlink" title="1. createComponent"></a>1. createComponent</h4><p>组件的创建最开始走的和<a href="../../../../2018/10/09/vue源码分析-数据驱动/#more">vue源码分析-数据驱动</a>章节的流程是一样的。也是，new Vue() ==&gt; this._init() ==&gt; initMixin() ==&gt; $mount() ==&gt; mountComponent() ==&gt; _render() ==&gt; $createElement ==&gt; createElement() ==&gt; _createElement()<br>但是，在_createElement()方法中，有一个判断，与之前的不一样<span class="font-color-red">if (typeof tag === ‘string’)</span><br><img src="createElement.png" alt="判断">在<a href="../../../../2018/10/09/vue源码分析-数据驱动/#more">vue源码分析-数据驱动</a>章节中，tag是一个‘div’满足，则直接进入判断中。此处是一个组件，tag则是一个对象<br><img src="tag_detail.png" alt="tag的详情">所以，直接进入createComponent方法中，并且传入了一系列的参数（tag,data,context,children）,其中只有tag以及context有值，并且context其实就是Vue。<br><img src="createComponent.png" alt="createComponent">其中context.$options._base其实就是Vue构造函数，Ctor就是tag，Ctor如果是对象的话，则会调用Vue.extend方法<br><img src="extend.png" alt="extend">extend方法主要是根据Vue构造函数创建一个Sub构造函数，并且在把传入的options和Vue上面原本挂载的options进行一个mergeOptions，将options内容进行合并，并且赋值给Sub.options，则当前组件就会含有自己的options，以及挂载在Vue上的全局component，directive，filter<br>其中，validateComponentName是用来检验组件名称是否合法合理。<br>sub构造函数中含有this. _ init()其实也就是上一章节中 _ init方法。<br>因此后期就会再次进入 _ init方法创建组件，直接进入initInternalComponent方法中，在initInternalComponent方法中，就是一系统的赋值等。</p><h4 id="2-patch"><a href="#2-patch" class="headerlink" title="2. patch"></a>2. patch</h4><p>在上面createComponent之后，进入createComponent方法中<br><img src="createComponent2.png" alt="createComponent2"><br>其中有一个installComponentHooks的方法，hooksToMerge其实就是一个对象，含有init，prepatch,insert,destory这四个字符串，通过便利，给data上添加上钩子函数（hook）<br><img src="installComponentHooks.png" alt="installComponentHooks"><br>将componentVNodeHooks对象中的相应的钩子函数赋值给data。<br>接着执行createComponent里面的方法new VNode，返回一个vnode<br>执行另外一个createComponent方法，调用原本赋值再vnode上的hook函数，将i的init方法赋值给i，再调用i方法<br><img src="createComponent3.png" alt="createComponent3"><br>进入原本hooksToMerge对象赋值给data上的init方法，通过createComponentInstanceForVnode函数创建组件对象<br><img src="componentVNodeHooks-init&amp;prepatch.png" alt="componentVNodeHooks-init&amp;prepatch"><br>在createComponentInstanceForVnode函数中，最终返回<span class="text-important">new vnode.componentOptions.Ctor(options)</span>，而vnode.componentOptions.Cto也就是我们在1. createComponent中利用Vue构造函数创建的一个Sub构造函数<br><img src="createComponentInstanceForVnode.png" alt="createComponentInstanceForVnode"><br>再次回到sub构造函数中，调用了this. _ init方法，其实也就是我们在<a href="../../../../2018/10/09/vue源码分析-数据驱动/#more">vue源码分析-数据驱动</a>章节中new Vue()后立马执行的初始化<br><img src="sub.png" alt="sub"><br>再次进入vue.prototype. _ init方法中，此时由于是组件，会调用initInternalComponent(vm, options);方法，而此时的没有el这个属性值没有值，则就不会去执行vm.$mount(vm.$options.el);<br>在initInternalComponent方法中，进行了一系列的赋值。其中注意：opts._parentVnode = parentVnode，则组件对象上的_parentVnode是一个占位node<br><img src="initInternalComponent.png" alt="initInternalComponent"><br>继续回到componentVNodeHooks中，调用child.$mount方法进行挂载，调用mountComponent，在mountComponent函数中定义 updateComponent = function () { vm._update(vm._render(), hydrating); }; 走起<a href="../../../../2018/10/09/vue源码分析-数据驱动/#more">vue源码分析-数据驱动</a>章节的流程（_render() ==&gt; $createElement ==&gt; createElement ==&gt; _createElement ==&gt; ）里层的元素组件进行上面的流程</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于弄懂了定义一个vue实例到渲染成页面DOM的整个过程，心情炒鸡棒，今天打算开始了解一下vue的另外一个核心思想 — &lt;strong&gt;组件化&lt;/strong&gt;。&lt;br&gt;所谓组件化，也就是将页面根据一些规则（业务/逻辑等）划分成一个个组件（Component），每个组件的css,js,模版,图片等资源都相互独立，每个组件的资源都放在一起开发维护。这样便于维护以及实现可复用～～～&lt;br&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript - 数据存储</title>
    <link href="http://yoursite.com/2018/10/10/JavaScript-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    <id>http://yoursite.com/2018/10/10/JavaScript-数据存储/</id>
    <published>2018-10-10T03:09:21.000Z</published>
    <updated>2018-10-29T09:44:03.165Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来都知道cookie、sessionStorage、localStorage这些用于缓存数据的,但并没有正式地去了解研究过它们，此次项目中用到这些知识，正好学习一波～<br>cookie：也就是HTTP cookie，客户端用于存储会话信息，是一个标准，并且要求服务器对任意HTTP请求发送Set-Cookie HTTP头作为响应的一部分。<br>Web Storage：一种为了存储大量可以跨会话存在的数据，新途径的标准。包含两种对象定义：sessionStorage、globalStorage……<br><a id="more"></a></p><h3 id="1-cookie"><a href="#1-cookie" class="headerlink" title="1. cookie"></a>1. cookie</h3><h3 id="2-Web-Storage"><a href="#2-Web-Storage" class="headerlink" title="2. Web Storage"></a>2. Web Storage</h3><h4 id="2-1-sessionStorage"><a href="#2-1-sessionStorage" class="headerlink" title="2.1 sessionStorage"></a>2.1 sessionStorage</h4><h4 id="2-2-globalStorage"><a href="#2-2-globalStorage" class="headerlink" title="2.2 globalStorage"></a>2.2 globalStorage</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来都知道cookie、sessionStorage、localStorage这些用于缓存数据的,但并没有正式地去了解研究过它们，此次项目中用到这些知识，正好学习一波～&lt;br&gt;cookie：也就是HTTP cookie，客户端用于存储会话信息，是一个标准，并且要求服务器对任意HTTP请求发送Set-Cookie HTTP头作为响应的一部分。&lt;br&gt;Web Storage：一种为了存储大量可以跨会话存在的数据，新途径的标准。包含两种对象定义：sessionStorage、globalStorage……&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>vue源码分析 - 数据驱动</title>
    <link href="http://yoursite.com/2018/10/09/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8/"/>
    <id>http://yoursite.com/2018/10/09/vue源码分析-数据驱动/</id>
    <published>2018-10-09T02:49:58.000Z</published>
    <updated>2018-10-29T09:43:38.166Z</updated>
    
    <content type="html"><![CDATA[<p>数据驱动是vue.js的一个重要的思想。数据驱动：视图根据数据驱动生成，我们不会通过直接修改dom来修改视图，会通过修改数据来完成对视图的修改。<br><a id="more"></a></p><blockquote><p>Runtime-only: 需要借助类似于webpack的vue-loader来将.vue文件编译成JavaScript。因为是在编译阶段做的，所以只包含运行时的Vue.js代码，代码体积更轻便。<br><br>Runtime + compiler: 没有对代码做预编译。因为在Vue.js2.0中，最后渲染都是通过render函数，如果编写了template，则需要编译成render函数，而这个编译过程发生在运行时，所以需要带有编译器的版本，并且这个编译过程对性能会有一定的损耗。</p></blockquote><h3 id="1-new"><a href="#1-new" class="headerlink" title="1. new"></a>1. new</h3><blockquote><p>new Vue()一个实例干了什么？</p></blockquote><p><img src="https://i.imgur.com/lny4o5V.png" alt="new vue时的代码"><br>new Vue()后只会判断使用的语法对不对，然后就调用已经挂载到Vue原型上的_init方法(通过initMixin(Vue))，在initMixin()之前，Vue上只有一个构造函数外加一个<strong>proto</strong>（也就是Object所含有的）。<br><img src="https://i.imgur.com/PNzomC5.png" alt="vue.prototype"></p><h3 id="2-init"><a href="#2-init" class="headerlink" title="2. init"></a>2. init</h3><p>initMixin方法在Vue.prototype上挂载了一个_init方法<br><img src="https://i.imgur.com/Yt9N7Rl.png" alt=""><br>在initMixin方法中：先将options进行整合（具体先不管）；<br>后又进行了一系统的初始化：生命周期初始化（initLifecycle）、事件初始化（initEvents）、渲染（initRender）、callHook()、初始化数据（initState）以及一些其它的初始化(initInjections、initProvide)</p><p>其中initState方法中含有initData方法(其中含有一个proxy(vm, “_data”, key)，为data中数据项进行一个代理设置)</p><p><img src="https://i.imgur.com/UHwd04N.png" alt=""><br>也就是利用了Object.defineProperty()方法来设置访问器属性，从而实现了直接修改类似this.message = 12也就是修改了this._data.message = 12</p><p>除了_data会使用proxy方法来进行一层设置代理，还会有_props，因此_data与_props里面定义的属性名称不能相同，不然就会出现覆盖的情况（写组件中经常就会遇见props中有一个a，data中也有一个a，则后期父组件修改a的值后，组件并不会跟着进行变化）</p><h3 id="3-mount"><a href="#3-mount" class="headerlink" title="3. $mount"></a>3. $mount</h3><p>在initMixin方法的最后根据vm.$options.el是否存在来决定是否挂载</p><p><code>if (vm.$options.el) {  vm.$mount(vm.$options.el);}</code></p><p>$mount方法是挂载在vue构造函数prototype上的，里面直接调用的是mountComponent方法，后期又定义了updateComponent函数（里面调用了vue上的 _update 方法， _update 方法中传递了vue的 _render 函数渲染出来的vnode以及hydrating），又新建了一个 <span style="color:red;">渲染watcher</span>(后期发生变化，进行更新的时候，会执行渲染watcher中的updateComponent方法，从而重新渲染了一次)</p><p><img src="$mount.png" alt="$mount"></p><p>该过程主要做了：对options.render进行一个判断，看看是否书写了render函数，如果没有写，则对template进行解析，(其中没有template的时候，会根据getOuterHTML来得到模版字符串)，然后会根据template进行编译（使用compileToFunction），编译得到render函数以及staticRenderFns静态render函数。因为vue只认render函数。<br><br>有了render函数之后，就会调用mount.call(this,el,hydrating)，这个mount函数其实就是vue.prototype.$mount。然后就会执行上面的过程（$mount）</p><h3 id="4-compile"><a href="#4-compile" class="headerlink" title="4. compile"></a>4. compile</h3><p>函数compileToFunction来进行编译，拿到render渲染函数以及staticRenderFns静态render函数</p><h3 id="5-render"><a href="#5-render" class="headerlink" title="5. render"></a>5. render</h3><p>_render方法是实例的一个私有方法，它用来把实例渲染成vnode（虚拟Node）。<br><img src="render.png" alt="_render"><br>vnode = render.call(vm. _renderProxy, vm.$createElement);<br>其中vm. _renderProxy是上下文，在生产环境下，就是vm实例，在开发环境下是一个Proxy实例。(会在init过程中有下面的代码)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">  initProxy(vm);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  vm._renderProxy = vm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$createElemt在initRender中定义，initRender函数在init中执行。在$createElement函数中调用了createElement方法，createElement方法会返回一个VNode</p><h3 id="6-vnode"><a href="#6-vnode" class="headerlink" title="6. vnode"></a>6. vnode</h3><p>产生的前提：浏览器中的DOM比较庞大，并且设计的比较复杂，频繁地去更新DOM，也会产生性能问题。Virtual DOM 使用js对象来描述DOM。<br>Virtual DOM除了数据结构的定义，映射到真实的DOM上，还需要经历VNode的create、diff、patch等过程。而Vue中的createElement就是VNode的create。</p><p><img src="createElement.png" alt="createElement"></p><p>createElement方法调用的是 _createElement方法，在 _createElement方法中，对children做了normalize处理（也就是将children变成一维数组，涉及到的方法有：normalizeChildren，normalizeArrayChildren，simpleNormalizeChildren）</p><h3 id="7-patch"><a href="#7-patch" class="headerlink" title="7. patch"></a>7. patch</h3><blockquote><p>通过 _render函数以及createElement函数拿到了VNode，如何渲染到真实DOM上呢？</p></blockquote><p>通过vue中 _update方法，将VNode渲染成真实的DOM，此方法会在两种情况下被调用：首次渲染，数据更新。</p><p><img src="update.png" alt="update"></p><p>其中，会走到vm.<strong> patch </strong> 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.__ patch __ = inBrowser ? patch : noop;</span><br></pre></td></tr></table></figure></p><p><br>在服务器端是没有DOM这个概念的，所以不在客户端中，则是不需要渲染成真实DOM的。<br>调用<strong>patch</strong>方法的时候，第一个参数是真实的DOM，第二个参数是我们得到的VNode。通过<strong>patch</strong>方法中的createElm将VNode挂载到真实的DOM上，(如果有子节点，则递归调用createElm，没有子节点，则直接创建一个DOM)，最后通过insert方法插入真实DOM中（里面分情况调用了insertBefore与appendChild）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据驱动是vue.js的一个重要的思想。数据驱动：视图根据数据驱动生成，我们不会通过直接修改dom来修改视图，会通过修改数据来完成对视图的修改。&lt;br&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Flow初识</title>
    <link href="http://yoursite.com/2018/10/06/Flow%E5%88%9D%E8%AF%86/"/>
    <id>http://yoursite.com/2018/10/06/Flow初识/</id>
    <published>2018-10-06T02:35:16.000Z</published>
    <updated>2018-10-29T09:43:14.759Z</updated>
    
    <content type="html"><![CDATA[<p>借助学习vue.js源码，在其过程中，认识到了Flow，该篇主要介绍一下最基本的Flow<br><a id="more"></a></p><h3 id="初识Flow"><a href="#初识Flow" class="headerlink" title="初识Flow"></a>初识Flow</h3><h4 id="1-是什么？"><a href="#1-是什么？" class="headerlink" title="1. 是什么？"></a>1. 是什么？</h4><p>Flow是一种静态类型检查工具，是一种工具。</p><blockquote><p>静态类型检查： 在编辑期间尽早发现（由类型引起的）bug，又不影响代码运行（不需要运行时动态检查类型）</p></blockquote><h4 id="2-Flow的工作方式"><a href="#2-Flow的工作方式" class="headerlink" title="2. Flow的工作方式"></a>2. Flow的工作方式</h4><h5 id="2-1-类型推断"><a href="#2-1-类型推断" class="headerlink" title="2.1 类型推断"></a>2.1 类型推断</h5><blockquote><p>通过变量使用上下文来推断出变量类型，然后根据这些推断来检查类型</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*@flow*/``</span><br><span class="line">function split(str) &#123;</span><br><span class="line">  return str.split(&apos; &apos;)</span><br><span class="line">&#125;</span><br><span class="line">split(11)</span><br></pre></td></tr></table></figure><p><span style="color:red;">会报错</span>：原因是我们期待的是字符串类型，但是传入的是数字类型</p><h5 id="2-2-类型注释"><a href="#2-2-类型注释" class="headerlink" title="2.2 类型注释"></a>2.2 类型注释</h5><blockquote><p>事先注释好我们期待的类型，Flow会基于这些注释来判断</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*@flow*/</span><br><span class="line"></span><br><span class="line">function add(x, y)&#123;</span><br><span class="line">  return x + y</span><br><span class="line">&#125;</span><br><span class="line">add(&apos;Hello&apos;, 11)</span><br></pre></td></tr></table></figure><p>上面的代码<span style="color:red;">不会报错</span>，Flow的检查不出来，因为‘+’可以用于字符串也可以用于数字<br>则，此时就需要使用类型注释（：）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*@flow*/</span><br><span class="line"></span><br><span class="line">function add(x: number, y: number): number &#123;</span><br><span class="line">  return x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(&apos;Hello&apos;, 11)</span><br></pre></td></tr></table></figure><ul><li>数组类型注释格式：Array&lt; T &gt;，T 表示数组中每项的数据类型</li><li>一个变量可能多个类型时，可以使用<span style="color:red;"> ‘|’ </span>来连接两种类型，表示或</li><li>若想任意类型<span style="color:red;"> T </span>可以为 null 或者 undefined，只需类似如下写成可以使用<span style="color:red;"> ?T </span>的格式即可</li></ul><hr><p>参考：<a href="https://flow.org/en/docs/getting-started/" target="_blank" rel="noopener">Flow官网</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;借助学习vue.js源码，在其过程中，认识到了Flow，该篇主要介绍一下最基本的Flow&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>vue源码解析</title>
    <link href="http://yoursite.com/2018/09/30/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/09/30/vue源码解析/</id>
    <published>2018-09-30T08:33:47.000Z</published>
    <updated>2018-10-29T09:43:46.265Z</updated>
    
    <content type="html"><![CDATA[<p>开始学习vue<br><a id="more"></a></p><h2 id="vue源码解析"><a href="#vue源码解析" class="headerlink" title="vue源码解析"></a>vue源码解析</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h3 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h3><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><h3 id="深入响应式原理"><a href="#深入响应式原理" class="headerlink" title="深入响应式原理"></a>深入响应式原理</h3><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始学习vue&lt;br&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
</feed>
