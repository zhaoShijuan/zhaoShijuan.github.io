<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>找试卷</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-20T07:09:35.683Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zhaoShijuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES6基础知识</title>
    <link href="http://yoursite.com/2019/05/20/ES6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/05/20/ES6基础知识/</id>
    <published>2019-05-20T07:09:15.000Z</published>
    <updated>2019-05-20T07:09:35.683Z</updated>
    
    <content type="html"><![CDATA[<p>#ES6基础知识点<br>JavaScript的组成：ECMAScript（核心）、DOM（文档对象模型）、BOM （浏览器对象模型）<br>ECMAScript，规定了语言的组成部分：语法、类型、语句、关键字、保留字、操作符、对象。我们现在使用的是ES5，也就是ECMAScript的第5版本。顾名思义，ES6就是ECMAScript的第6版本，在ES5的基础上，在保证向下兼容的前提下，提供大量新特性。</p><h2 id="一、let-const命令"><a href="#一、let-const命令" class="headerlink" title="一、let const命令"></a>一、let const命令</h2><h3 id="1-let"><a href="#1-let" class="headerlink" title="1. let"></a>1. let</h3><p>let用于声明变量，用法类似于var<br><span class="text-important">let与const的区别如下：</span></p><h5 id="1-1-let声明的变量只在let命令所在的代码块中有效"><a href="#1-1-let声明的变量只在let命令所在的代码块中有效" class="headerlink" title="1.1 let声明的变量只在let命令所在的代码块中有效"></a>1.1 let声明的变量只在let命令所在的代码块中有效</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="keyword">var</span> a = <span class="number">10</span>;<span class="keyword">let</span> b = <span class="number">1</span>;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a)<span class="comment">//==&gt;10</span></span><br><span class="line"><span class="built_in">console</span>.log(b)<span class="comment">//==&gt;报错：b is not defined</span></span><br><span class="line"></span><br><span class="line">典型案例：</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);<span class="comment">//==&gt;i is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">a[i] =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>]();<span class="comment">//==&gt;10   变量i是var声明的，在全局范围内都有效，每次循环，新的i会覆盖掉旧的i</span></span><br></pre></td></tr></table></figure><h5 id="1-2-不存在变量提升-使用let时，一定要在变量声明后使用，否则会报错"><a href="#1-2-不存在变量提升-使用let时，一定要在变量声明后使用，否则会报错" class="headerlink" title="1.2 不存在变量提升,使用let时，一定要在变量声明后使用，否则会报错"></a>1.2 不存在变量提升,使用let时，一定要在变量声明后使用，否则会报错</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(foo);//===&gt;ReferenceError:foo is not defined</span><br><span class="line">let foo = 2;</span><br><span class="line">&lt;notice&gt;：此时使用typeof不再是一个百分之百安全操作</span><br></pre></td></tr></table></figure><h5 id="1-3-暂时性死区（TDZ）"><a href="#1-3-暂时性死区（TDZ）" class="headerlink" title="1.3 暂时性死区（TDZ）"></a>1.3 暂时性死区（TDZ）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//只要块级作用域内存在let命令,它所声明的变量就绑定在这个区域，不再受外部的影响</span><br><span class="line">var tmp = 123;</span><br><span class="line">if(true)&#123;</span><br><span class="line">tmp = &apos;abc&apos;;</span><br><span class="line">let tmp;</span><br><span class="line">&#125;</span><br><span class="line">//如果区块中存在let和const命令，则这个区块对这些命令声明的变量从一开始就形成封闭作用域</span><br><span class="line"></span><br><span class="line">function bar(x = y,y = 2)&#123;</span><br><span class="line">return [x,y];</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><h5 id="1-4-不允许重复声明"><a href="#1-4-不允许重复声明" class="headerlink" title="1.4 不允许重复声明"></a>1.4 不允许重复声明</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let不允许在相同作用域内重复声明同一个变量</span><br><span class="line">function()&#123;</span><br><span class="line">let a = 10;</span><br><span class="line">let a = 8;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function(arg)&#123;</span><br><span class="line">let arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function(arg)&#123;</span><br><span class="line">&#123;let arg;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-const"><a href="#2-const" class="headerlink" title="2. const"></a>2. const</h3><p>const 用来声明常量，一旦声明，其值就不能改变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const PI = 3.14;&lt;br/&gt;</span><br><span class="line">PI = 3;//==&gt;TypeError:&apos;PI&apos; is read-only</span><br></pre></td></tr></table></figure><blockquote><p>2.1 const 一旦声明常量，就必须立即初始化，不能留到以后赋值；<br><br>2.2 const 只声明不赋值就会报错；SyntaxError:missing = in const declaration<br><br>2.3 const 作用域与let命令相同：只在声明所在的块级作用域内有效<br><br>2.4 const 也存在暂时性死区，只能在声明后使用<br><br>2.5 const 不可重复声明常量<br><br>2.6 对于复合类型的变量，变量名指向地址，不指向数据<br></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const foo = &#123;&#125;;</span><br><span class="line">foo.prop = 123;</span><br><span class="line">console.log(foo.prop);//==&gt;123</span><br><span class="line"></span><br><span class="line">想对对象冻结，使用 Object.freeze,冻结对象本身，冻结对象的属性</span><br><span class="line">const foo = Object.freeze(&#123;&#125;);</span><br><span class="line">foo.prop = 123;//==&gt;不起作用,冻结的对象，添加新属性不起作用</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="二、模板字符串"><a href="#二、模板字符串" class="headerlink" title="二、模板字符串"></a>二、模板字符串</h2><p><code>&lt;html&gt;&lt;/html&gt;</code> 传统的写法就是用+进行拼接,并且还要考虑到单引号与双引号的交替以及转义，并且不能换行<br>模板字符串直接使用反引号 `` 可以定义多行代码，并且嵌入变量<br><br><span class="text-important">使用模板字符串的注意如下：</span></p><h5 id="2-1-转义"><a href="#2-1-转义" class="headerlink" title="2.1 ``转义  +``"></a>2.1 ``转义  +``</h5><h5 id="2-2-多行字符串，所有的空格以及缩进都会被保留在输出中"><a href="#2-2-多行字符串，所有的空格以及缩进都会被保留在输出中" class="headerlink" title="2.2 多行字符串，所有的空格以及缩进都会被保留在输出中"></a>2.2 多行字符串，所有的空格以及缩进都会被保留在输出中</h5><h5 id="2-3-嵌入变量，需要将变量名写在"><a href="#2-3-嵌入变量，需要将变量名写在" class="headerlink" title="2.3 嵌入变量，需要将变量名写在${}"></a>2.3 嵌入变量，需要将变量名写在${}</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function(name,value)&#123;</span><br><span class="line">throw new Error(&apos;name:&apos;+name+&apos;;value:&apos;+value);//以前写法</span><br><span class="line">throw new Error(`name:$&#123;name&#125;;value:$&#123;value&#125;`);//模板字符串写法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-4-调用函数"><a href="#2-4-调用函数" class="headerlink" title="2.4 调用函数"></a>2.4 调用函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">return &apos;nihao&apos;;</span><br><span class="line">&#125;</span><br><span class="line">`everyone,$&#123;fn()&#125; yiyi`//==&gt;everyone,nihao yiyi</span><br></pre></td></tr></table></figure><h5 id="2-5-大括号中的值不是字符串，按照一般的规则转为字符串"><a href="#2-5-大括号中的值不是字符串，按照一般的规则转为字符串" class="headerlink" title="2.5 ${}大括号中的值不是字符串，按照一般的规则转为字符串"></a>2.5 ${}大括号中的值不是字符串，按照一般的规则转为字符串</h5><p>对象 – toString()<br><br>方法 – 执行方法后得到的值</p><p><br><br><br></p><h2 id="三、变量的解构赋值"><a href="#三、变量的解构赋值" class="headerlink" title="三、变量的解构赋值"></a>三、变量的解构赋值</h2><p><span class="text-important">按照一定模式，从数组和对象中提取值，对变量进行赋值。</span>类似于“模式匹配”</p><h3 id="1-数组解构赋值"><a href="#1-数组解构赋值" class="headerlink" title="1. 数组解构赋值"></a>1. 数组解构赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let [a, b] = [1, 2] // let a = 1; let b = 2;</span><br><span class="line">let [a, b, [c, d]] = [1, 2, [3, 4]] // let a = 1; b = 2; let c = 3; let d = 4;</span><br><span class="line">let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]; // let third = &quot;baz&quot;;</span><br><span class="line">let [x, , y] = [1, 2, 3]; // let x = 1; y = 3;</span><br><span class="line">let [head, ...tail] = [1, 2, 3, 4]; // let head = 1; let tail = [2, 3, 4];</span><br></pre></td></tr></table></figure><h5 id="1-1-解构不成功，值就会变成undefined"><a href="#1-1-解构不成功，值就会变成undefined" class="headerlink" title="1.1 解构不成功，值就会变成undefined"></a>1.1 解构不成功，值就会变成undefined</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let [x, y, ...z] = [&apos;1&apos;] // let x = &apos;1&apos;; let y = undefined; let z = [];</span><br></pre></td></tr></table></figure><h5 id="1-2-如果等号的右边不是数组，将会报错。"><a href="#1-2-如果等号的右边不是数组，将会报错。" class="headerlink" title="1.2 如果等号的右边不是数组，将会报错。"></a>1.2 如果等号的右边不是数组，将会报错。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">let [foo] = 1;</span><br><span class="line">let [foo] = false;</span><br><span class="line">let [foo] = NaN;</span><br><span class="line">let [foo] = undefined;</span><br><span class="line">let [foo] = null;</span><br><span class="line">let [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure><p><span class="text-important">只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</span></p><h5 id="1-3-解构赋值允许指定默认值"><a href="#1-3-解构赋值允许指定默认值" class="headerlink" title="1.3 解构赋值允许指定默认值"></a>1.3 解构赋值允许指定默认值</h5><blockquote><p>只有当一个数组成员严格等于(===)undefined，默认值才会生效</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let [x = 1] = []; // x = 1</span><br><span class="line">let [x, y = &apos;aaa&apos;] = [1, undefined]; // x = 1; y = &apos;aaa&apos;</span><br><span class="line">let [x = 1] = [null]; // x = 1</span><br></pre></td></tr></table></figure><blockquote><p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  console.log(&apos;aaa&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let [x = f()] = [1];</span><br></pre></td></tr></table></figure><blockquote><p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let [x = 1, y = x] = [];     // x=1; y=1</span><br><span class="line">let [x = 1, y = x] = [2];    // x=2; y=2</span><br><span class="line">let [x = 1, y = x] = [1, 2]; // x=1; y=2</span><br><span class="line">let [x = y, y = 1] = [];     // ReferenceError: y is not defined</span><br></pre></td></tr></table></figure><h3 id="2-对象解构赋值"><a href="#2-对象解构赋值" class="headerlink" title="2. 对象解构赋值"></a>2. 对象解构赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let &#123;a, b&#125; = &#123;a: 1, b: 2&#125; // a = 1; b = 2;</span><br></pre></td></tr></table></figure><blockquote><p>数组的解构与对象解构的不同：数组的元素是<span class="text-important">按次序排列</span>的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与<span class="text-important">属性同名</span>，才能取到正确的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let &#123;sin, cos&#125; = Math</span><br></pre></td></tr></table></figure></p></blockquote><h5 id="2-1-变量名和属性名不一致"><a href="#2-1-变量名和属性名不一致" class="headerlink" title="2.1 变量名和属性名不一致"></a>2.1 变量名和属性名不一致</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">a</span>: m, <span class="attr">b</span>: n&#125; = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125; <span class="comment">// m = 1; n = 2;</span></span><br></pre></td></tr></table></figure><p>a,b其实是匹配的模式，而真正的变量是m,n<br>以前所写的<code>let {a, b} = {1, 2}</code>其实是<code>let {a: a, b: b} = {a: 1, b: 2}</code>的缩写</p><h5 id="2-2-嵌套解构"><a href="#2-2-嵌套解构" class="headerlink" title="2.2 嵌套解构"></a>2.2 嵌套解构</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = &#123;</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; loc, <span class="attr">loc</span>: &#123; start &#125;, <span class="attr">loc</span>: &#123; <span class="attr">start</span>: &#123; line &#125;&#125; &#125; = node;</span><br></pre></td></tr></table></figure><p>上面代码有三次解构赋值，分别是对loc、start、line三个属性的解构赋值。注意，最后一次对line属性的解构赋值之中，只有line是变量，loc和start都是模式，不是变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;;</span><br><span class="line">let arr = [];</span><br><span class="line"></span><br><span class="line">(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);</span><br></pre></td></tr></table></figure><h5 id="2-3-对象解构也有默认值，默认值起作用的条件也是严格等于（-）undefined时"><a href="#2-3-对象解构也有默认值，默认值起作用的条件也是严格等于（-）undefined时" class="headerlink" title="2.3 对象解构也有默认值，默认值起作用的条件也是严格等于（===）undefined时"></a>2.3 对象解构也有默认值，默认值起作用的条件也是严格等于（===）undefined时</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let &#123;x: y = 5, z: m = 1, w = 3&#125; = &#123;null&#125;</span><br></pre></td></tr></table></figure><h3 id="3-解构注意的点⚠️"><a href="#3-解构注意的点⚠️" class="headerlink" title="3. 解构注意的点⚠️"></a>3. 解构注意的点⚠️</h3><h5 id="3-1-将一个已经声明的变量用于解构赋值"><a href="#3-1-将一个已经声明的变量用于解构赋值" class="headerlink" title="3.1 将一个已经声明的变量用于解构赋值"></a>3.1 将一个已经声明的变量用于解构赋值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let x;</span><br><span class="line">&#123;x&#125; = &#123;x: 1&#125;; // 会报错，因为&#123;x&#125;会被认为是一个代码块</span><br><span class="line">(&#123;x&#125; = &#123;x: 1&#125;);</span><br></pre></td></tr></table></figure><h5 id="3-2-解构赋值允许等号左边的模式之中，不放置任何变量名"><a href="#3-2-解构赋值允许等号左边的模式之中，不放置任何变量名" class="headerlink" title="3.2 解构赋值允许等号左边的模式之中，不放置任何变量名"></a>3.2 解构赋值允许等号左边的模式之中，不放置任何变量名</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125; = [true, false]);</span><br><span class="line">(&#123;&#125; = &apos;abc&apos;);</span><br><span class="line">(&#123;&#125; = []);</span><br></pre></td></tr></table></figure><p>不会报错，可以执行，但是没有任何意义</p><h5 id="3-3-由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构"><a href="#3-3-由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构" class="headerlink" title="3.3 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构"></a>3.3 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obj =&#123;&#125;;</span><br><span class="line">let arr = [];</span><br><span class="line">let &#123;name: obj.name, index: arr[0]&#125; = &#123;name: &apos;zhaoshijuan&apos;, index: 1&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3];</span><br><span class="line">let &#123;0 : first, [arr.length - 1] : last&#125; = arr;</span><br><span class="line">// first = 1; last = 3;</span><br></pre></td></tr></table></figure><blockquote><p>除了数组，对象可以解构赋值，还有字符串，布尔值，数值，函数参数等的解构赋值，需要大家自己去学习。</p></blockquote><p><br><br><br></p><h2 id="四、箭头函数"><a href="#四、箭头函数" class="headerlink" title="四、箭头函数"></a>四、箭头函数</h2><p><span class="text-important">定义函数: var f = v =&gt; v;</span>相当于: var f = function(v){return v;}</p><h5 id="1-无参数或者需要多个参数，使用圆括号代表参数部分"><a href="#1-无参数或者需要多个参数，使用圆括号代表参数部分" class="headerlink" title="1. 无参数或者需要多个参数，使用圆括号代表参数部分"></a>1. 无参数或者需要多个参数，使用圆括号代表参数部分</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var f = () =&gt;5;</span><br><span class="line">相当于：var f = function()&#123;return 5;&#125;</span><br><span class="line">var f = (num1,num2) =&gt; num1+num2;</span><br><span class="line">相当于：var f = function(num1,num2)&#123;return num1+num2;&#125;</span><br></pre></td></tr></table></figure><h5 id="2-代码块部分多于一行代码，使用大括号包裹起来"><a href="#2-代码块部分多于一行代码，使用大括号包裹起来" class="headerlink" title="2. 代码块部分多于一行代码，使用大括号包裹起来"></a>2. 代码块部分多于一行代码，使用大括号包裹起来</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var f = (num1,num2) =&gt; &#123;return num1+num2;&#125;</span><br></pre></td></tr></table></figure><h5 id="3-大括号是被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号"><a href="#3-大括号是被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号" class="headerlink" title="3. 大括号是被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号"></a>3. 大括号是被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号</h5><pre><code>var getTempItem = id =&gt; ({id:id,name:&apos;Temp&apos;});</code></pre><h5 id="4-作用：简化回调函数"><a href="#4-作用：简化回调函数" class="headerlink" title="4. 作用：简化回调函数"></a>4. 作用：简化回调函数</h5><pre><code>var result = values.sort(function(a,b){return a-b;});var result = values.sort((a,b) =&gt; a-b);</code></pre><h5 id="5-rest参数与箭头函数的结合"><a href="#5-rest参数与箭头函数的结合" class="headerlink" title="5. rest参数与箭头函数的结合"></a>5. rest参数与箭头函数的结合</h5><pre><code>const numbers = (...nums) =&gt; nums;numbers(1,2,3,4,5,6);//==&gt;[1,2,3,4,5,6]const headAndTail = (head,...tail) =&gt; [head,tail]headAndTail(1,2,3,4,5);//==&gt;[1,[2,3,4,5]]</code></pre><h3 id="⚠️注意："><a href="#⚠️注意：" class="headerlink" title="⚠️注意："></a>⚠️注意：</h3><p>1⃣️函数体内的this对象就是定义时所在的对象，而不是使用时所在的对象<br><br>2⃣️不可以当做构造函数<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">return () =&gt; &#123;</span><br><span class="line">return () =&gt;&#123;</span><br><span class="line">return () =&gt;&#123;</span><br><span class="line">console.log(&apos;id&apos;,this.id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//这串代码只有一个this，也就是foo的this,箭头函数是没有this的，所以就不能当做构造函数&lt;br/&gt;</span><br></pre></td></tr></table></figure><p>3⃣️不可以使用arguments对象，该对象在函数体内不存在，如果要使用，可以使用rest参数代替<br><br>//除了this，arguments、super、new.target在箭头函数中也是不存在的</p><p><br><br><br></p><h2 id="五、Symbol"><a href="#五、Symbol" class="headerlink" title="五、Symbol"></a>五、Symbol</h2><p>Symbol 独一无二的值，是js语言的第7种数据类型 （Undefined,Null,Boolean,String,Number,Object）</p><h3 id="1-使用注意"><a href="#1-使用注意" class="headerlink" title="1. 使用注意"></a>1. 使用注意</h3><h5 id="1-1-symbol值通过symbol函数生成-symbol值不是对象"><a href="#1-1-symbol值通过symbol函数生成-symbol值不是对象" class="headerlink" title="1.1 symbol值通过symbol函数生成,symbol值不是对象"></a>1.1 symbol值通过symbol函数生成,symbol值不是对象</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let s = Symbol();</span><br><span class="line">console.log(typeof s);//==&gt;symbol</span><br></pre></td></tr></table></figure><h5 id="1-2-可以接受一个字符串作为参数，用于对symbol实例的描述"><a href="#1-2-可以接受一个字符串作为参数，用于对symbol实例的描述" class="headerlink" title="1.2 可以接受一个字符串作为参数，用于对symbol实例的描述"></a>1.2 可以接受一个字符串作为参数，用于对symbol实例的描述</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var s1 = Symbol(&apos;foo&apos;);</span><br><span class="line">console.log(s1);//==&gt;Symbol(foo)</span><br><span class="line">console.log(s1.toString);//==&gt;&apos;Symbol(foo)&apos;</span><br></pre></td></tr></table></figure><h5 id="1-3-Symbol值不能与其他类型的值进行运算"><a href="#1-3-Symbol值不能与其他类型的值进行运算" class="headerlink" title="1.3 Symbol值不能与其他类型的值进行运算"></a>1.3 Symbol值不能与其他类型的值进行运算</h5><h5 id="1-4-Symbol值可以显式转为字符串"><a href="#1-4-Symbol值可以显式转为字符串" class="headerlink" title="1.4 Symbol值可以显式转为字符串"></a>1.4 Symbol值可以显式转为字符串</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var sym = Symbol(&apos;my symbol&apos;);</span><br><span class="line">console.log(String(sym));//==&gt;&apos;Symbol(&apos;my symbol&apos;)&apos;</span><br><span class="line">console.log(sym.toString());//==&gt;&apos;Symbol(&apos;my symbol&apos;)&apos;</span><br></pre></td></tr></table></figure><h5 id="1-5-Symbol值可以转为Boolean值"><a href="#1-5-Symbol值可以转为Boolean值" class="headerlink" title="1.5 Symbol值可以转为Boolean值"></a>1.5 Symbol值可以转为Boolean值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var sym1 = Symbol();</span><br><span class="line">console.log(Boolean(sym1));//==&gt;true</span><br><span class="line">console.log(Boolean(!sym1));//==&gt;false</span><br></pre></td></tr></table></figure><h3 id="2-作为属性名的Symbol"><a href="#2-作为属性名的Symbol" class="headerlink" title="2. 作为属性名的Symbol"></a>2. 作为属性名的Symbol</h3><p>每一个symbol值都是不相等的，因此不会出现同名的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var mySymbol = Symbol();</span><br><span class="line">var a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = &apos;helloWorld&apos;; </span><br><span class="line">var a = &#123;[mySymbol]:&apos;helloWorld&apos;&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-1-Symbol值作为对象属性名时不能使用点运算符，要放在方括号中"><a href="#2-1-Symbol值作为对象属性名时不能使用点运算符，要放在方括号中" class="headerlink" title="2.1 Symbol值作为对象属性名时不能使用点运算符，要放在方括号中"></a>2.1 Symbol值作为对象属性名时不能使用点运算符，要放在方括号中</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var mySymbol = Symbol();</span><br><span class="line">var a = &#123;&#125;;</span><br><span class="line">a.mySymbol = &apos;helloWorld&apos;;</span><br><span class="line">console.log(a[mySymbol]);//==&gt;undefined</span><br><span class="line">console.log(a[&apos;mySymbol&apos;]);//==&gt;&apos;helloWorld&apos;</span><br><span class="line">//此时，a的属性名相当于是一个字符串，而不是一个Symbol值</span><br><span class="line"></span><br><span class="line">let s = Symbol();</span><br><span class="line">let obj = &#123;[s]:function(arg)&#123;...&#125;&#125;</span><br><span class="line">console.log(obj[s]);//==&gt;function(arg)&#123;...&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-Symbol类型还可用于定义一组常量，保证这组常量的值都是不相等的。"><a href="#2-2-Symbol类型还可用于定义一组常量，保证这组常量的值都是不相等的。" class="headerlink" title="2.2 Symbol类型还可用于定义一组常量，保证这组常量的值都是不相等的。"></a>2.2 Symbol类型还可用于定义一组常量，保证这组常量的值都是不相等的。</h5><h5 id="2-3-消除魔术字符串"><a href="#2-3-消除魔术字符串" class="headerlink" title="2.3 消除魔术字符串"></a>2.3 消除魔术字符串</h5><p>魔术字符串：在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或数值<br>使用同一个Symbol</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Symbol.for()</span><br><span class="line">var a = Symbol.for(&apos;foo&apos;);</span><br><span class="line">var b = Symbol.for(&apos;foo&apos;);</span><br><span class="line">console.log(a === b);//==&gt;true</span><br></pre></td></tr></table></figure><p><br><br><br></p><h2 id="六、Promise"><a href="#六、Promise" class="headerlink" title="六、Promise"></a>六、Promise</h2><p><span class="text-important">所谓Promise</span>，简单说就是一个<code>容器</code>，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><h3 id="1-Promise特点"><a href="#1-Promise特点" class="headerlink" title="1. Promise特点"></a>1. Promise特点</h3><blockquote><p>1.对象的状态不受外界的影响，三种状态：pending(进行中),fufilled(已成功),rejected(已失败)<br><br>2.一旦状态改变，就不会再变。状态的两种改变：pending—&gt;fulfilled,pending—&gt;rejected</p></blockquote><h3 id="2-promise对象是一个构造函数，用来生成promise实例"><a href="#2-promise对象是一个构造函数，用来生成promise实例" class="headerlink" title="2. promise对象是一个构造函数，用来生成promise实例"></a>2. promise对象是一个构造函数，用来生成promise实例</h3><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  // ... some code</span><br><span class="line">  if (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">//resolve 将Promise对象的状态pending---&gt;fulfilled，</span><br><span class="line">//reject  将Promise对象的状态pending---&gt;rejected</span><br></pre></td></tr></table></figure><h3 id="3-then方法指定resolved和rejected回调-then方法返回的是一个新的Promise实例-因此可以使用链式写法"><a href="#3-then方法指定resolved和rejected回调-then方法返回的是一个新的Promise实例-因此可以使用链式写法" class="headerlink" title="3. then方法指定resolved和rejected回调,then方法返回的是一个新的Promise实例,因此可以使用链式写法"></a>3. then方法指定resolved和rejected回调,then方法返回的是一个新的Promise实例,因此可以使用链式写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">promise.then(function(value)&#123;</span><br><span class="line">console.log(&apos;sucess  resolved&apos;)</span><br><span class="line">&#125;,function(error)&#123;</span><br><span class="line">console.log(&apos;failure rejected(可选)&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function timeout(ms) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, ms, &apos;done&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">timeout(100).then((value) =&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;);</span><br><span class="line">//链式写法</span><br><span class="line">promise.then(function(value)&#123;</span><br><span class="line">console.log(&apos;sucess  resolved&apos;)</span><br><span class="line">&#125;,function(error)&#123;</span><br><span class="line">console.log(&apos;failure rejected(可选)&apos;)</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">console.log(&apos;then==&gt;sucess&apos;);</span><br><span class="line">&#125;,function()&#123;</span><br><span class="line">console.log(&apos;then==&gt;failure&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-Promise-新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。"><a href="#4-Promise-新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。" class="headerlink" title="4. Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。"></a>4. Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  console.log(&apos;Promise&apos;);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(function() &#123;</span><br><span class="line">  console.log(&apos;resolved&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&apos;Hi!&apos;);</span><br><span class="line">// Promise</span><br><span class="line">// Hi!</span><br><span class="line">// resolved</span><br><span class="line"></span><br><span class="line">var p1 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  console.log(&apos;Promise===&gt;p1&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">var p2 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">  console.log(&apos;Promise===&gt;p2&apos;);</span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;outside&apos;);</span><br></pre></td></tr></table></figure><p>p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行</p><h3 id="5-catch方法是用于指定发生错误时的回调函数"><a href="#5-catch方法是用于指定发生错误时的回调函数" class="headerlink" title="5. catch方法是用于指定发生错误时的回调函数"></a>5. catch方法是用于指定发生错误时的回调函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(&apos;/posts.json&apos;).then(function(posts) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;).catch(function(error) &#123;</span><br><span class="line">  // 处理 getJSON 和 前一个回调函数运行时发生的错误</span><br><span class="line">  console.log(&apos;发生错误！&apos;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  throw new Error(&apos;test&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(function(error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br><span class="line">// Error: test</span><br><span class="line"></span><br><span class="line">//如果Promise状态已经变成resolved，再抛出错误是无效的。</span><br><span class="line">var promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">resolve(&apos;ok&apos;);</span><br><span class="line">throw new Error(&apos;test&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(function(value) &#123; console.log(value) &#125;)</span><br><span class="line">.catch(function(error) &#123; console.log(error) &#125;);</span><br><span class="line">// ok</span><br><span class="line"></span><br><span class="line">// Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。</span><br><span class="line">var promise = new Promise(function()&#123;</span><br><span class="line">console.log(&apos;p1==&gt;sucess&apos;)</span><br><span class="line">&#125;,function()&#123;</span><br><span class="line">throw new Error(&apos;test&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(function()&#123;</span><br><span class="line">console.log(&apos;p2==&gt;sucess&apos;);</span><br><span class="line">throw new Error(&apos;test&apos;);</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">console.log(&apos;p3==&gt;sucess&apos;);</span><br><span class="line">&#125;).catch(function(error)&#123;</span><br><span class="line">console.log(error);//捕获前三个Promise实例的错误</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="6-Promise-all-用于将多个Promise实例包装成一个新的Promise实例"><a href="#6-Promise-all-用于将多个Promise实例包装成一个新的Promise实例" class="headerlink" title="6. Promise.all() 用于将多个Promise实例包装成一个新的Promise实例"></a>6. Promise.all() 用于将多个Promise实例包装成一个新的Promise实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Promise(function(resolve,reject)&#123;</span><br><span class="line">console.log(&apos;p1&apos;);</span><br><span class="line">resolve(&apos;promise1&apos;);</span><br><span class="line">&#125;),p2 = new Promise(function(resolve,reject)&#123;</span><br><span class="line">console.log(&apos;p2&apos;);</span><br><span class="line">resolve(&apos;promise2&apos;);</span><br><span class="line">&#125;),p3 = new Promise(function(resolve,reject)&#123;</span><br><span class="line">console.log(&apos;p3&apos;);</span><br><span class="line">resolve(&apos;promise3&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">var p = Promise.all([p1,p2,p3]);</span><br><span class="line">console.log(p);</span><br><span class="line"></span><br><span class="line">===&gt;p1、p2、p3只要有一个rejected，p就会变成rejected;只有全部是fulfilled,p才会变成fulfilled</span><br></pre></td></tr></table></figure><h3 id="7-Promise-race-将多个Promise实例包装成一个新的Promise实例"><a href="#7-Promise-race-将多个Promise实例包装成一个新的Promise实例" class="headerlink" title="7. Promise.race()  将多个Promise实例包装成一个新的Promise实例"></a>7. Promise.race()  将多个Promise实例包装成一个新的Promise实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var p = Promise.race([p1,p2,p3]);</span><br><span class="line">//只要p1,p2,p3有一个率先改变状态,p就会跟着改变。率先改变的Promise实例的返回值,就传递给p的回调函数</span><br><span class="line">const p = Promise.race([</span><br><span class="line">  fetch(&apos;/resource-that-may-take-a-while&apos;),</span><br><span class="line">  new Promise(function (resolve, reject) &#123;</span><br><span class="line">    setTimeout(() =&gt; reject(new Error(&apos;request timeout&apos;)), 5000)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line">p.then(response =&gt; console.log(response));</span><br><span class="line">p.catch(error =&gt; console.log(error));</span><br></pre></td></tr></table></figure><h3 id="8-Promise-reject-将对象转为Promise对象，并且状态为rejected"><a href="#8-Promise-reject-将对象转为Promise对象，并且状态为rejected" class="headerlink" title="8. Promise.reject() 将对象转为Promise对象，并且状态为rejected"></a>8. Promise.reject() 将对象转为Promise对象，并且状态为rejected</h3><h3 id="9-Promise-resolve-将对象转为Promise对象，并且状态为resolved"><a href="#9-Promise-resolve-将对象转为Promise对象，并且状态为resolved" class="headerlink" title="9. Promise.resolve() 将对象转为Promise对象，并且状态为resolved"></a>9. Promise.resolve() 将对象转为Promise对象，并且状态为resolved</h3><p><br><br><br></p><h2 id="七、Module语法"><a href="#七、Module语法" class="headerlink" title="七、Module语法"></a>七、Module语法</h2><blockquote><p>前言：只介绍module的语法以及使用过程中的注意事项，不会介绍原理，感兴趣的可以自己去研究。</p></blockquote><p>由于原生JavaScript没有模块这一个概念，对于过长的JavaScript文件而言，只能拆分，但是彼此之间又不能建立联系（除了使用window顶层对象，但是这种方法是不提倡的），后期社区执行了一些模块加载方案，主要就是CommonJs与AMD。CommonJs主要应用于服务器端（NodeJs）；AMD主要用于客户端（Javascript），其中最常用的就是RequireJs。<br><br>ES6的module可以在服务器端，也可以在客户端，而且语法一致。<br><br>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”「ES5的东西，大家可以自己去看看」。ES6模块中的this指向undefined。</p><blockquote><p>模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能</p></blockquote><h3 id="1-export"><a href="#1-export" class="headerlink" title="1. export"></a>1. export</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export var a = 1;</span><br><span class="line">export var b = &apos;zhaoshijuan&apos;;</span><br><span class="line">export var c = true;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var b = &apos;zhaoshijuan&apos;;</span><br><span class="line">var c = true;</span><br><span class="line">export &#123;a, b, c&#125;</span><br></pre></td></tr></table></figure><h5 id="1-1-别名"><a href="#1-1-别名" class="headerlink" title="1.1 别名"></a>1.1 别名</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function v1() &#123; ... &#125;</span><br><span class="line">function v2() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">export &#123;</span><br><span class="line">  v1 as streamV1,</span><br><span class="line">  v2 as streamV2,</span><br><span class="line">  v2 as streamLatestVersion</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用<code>as</code>关键字，重新命名了函数v1和v2的对外接口。</p><h5 id="1-2-export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系"><a href="#1-2-export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系" class="headerlink" title="1.2 export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系"></a>1.2 export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 报错,直接输出1，1只是一个值，不是接口</span><br><span class="line">export 1;</span><br><span class="line"></span><br><span class="line">// 报错，通过变量m，还是输出1</span><br><span class="line">var m = 1;</span><br><span class="line">export m;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">export var m = 1;</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">var m = 1;</span><br><span class="line">export &#123;m&#125;;</span><br><span class="line"></span><br><span class="line">// 写法三</span><br><span class="line">var n = 1;</span><br><span class="line">export &#123;n as m&#125;;</span><br></pre></td></tr></table></figure><h5 id="1-3-export命令可以出现在模块的任何位置，只要处于模块顶层就可以。"><a href="#1-3-export命令可以出现在模块的任何位置，只要处于模块顶层就可以。" class="headerlink" title="1.3 export命令可以出现在模块的任何位置，只要处于模块顶层就可以。"></a>1.3 export命令可以出现在模块的任何位置，只要处于模块顶层就可以。</h5><p>如果处于块级作用域内，就会报错，import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。</p><h3 id="2-import"><a href="#2-import" class="headerlink" title="2. import"></a>2. import</h3><p>使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">import &#123;firstName, lastName, year&#125; from &apos;./profile.js&apos;;</span><br><span class="line"></span><br><span class="line">function setName(element) &#123;</span><br><span class="line">  element.textContent = firstName + &apos; &apos; + lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>form</code>后面的是模块的位置，可以是绝对路径，也可以是相对路径。.js的后缀可以省略。</p><h5 id="2-1-大括号里面的变量名，必须与被导入模块对外接口的名称相同"><a href="#2-1-大括号里面的变量名，必须与被导入模块对外接口的名称相同" class="headerlink" title="2.1 大括号里面的变量名，必须与被导入模块对外接口的名称相同"></a>2.1 大括号里面的变量名，必须与被导入模块对外接口的名称相同</h5><h5 id="2-2-别名使用as"><a href="#2-2-别名使用as" class="headerlink" title="2.2 别名使用as"></a>2.2 别名使用as</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; lastName as surname &#125; from &apos;./profile.js&apos;;</span><br></pre></td></tr></table></figure><h5 id="2-3-import命名输入的变量是只读"><a href="#2-3-import命名输入的变量是只读" class="headerlink" title="2.3 import命名输入的变量是只读"></a>2.3 import命名输入的变量是只读</h5><p>如果是一个对象，则对象里面的属性是可写的，但是不利于后期的排错什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123;a&#125; from &apos;./xxx.js&apos;</span><br><span class="line">a.foo = &apos;hello&apos;; // 合法操作</span><br></pre></td></tr></table></figure><h5 id="2-4-如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次"><a href="#2-4-如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次" class="headerlink" title="2.4 如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次"></a>2.4 如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次</h5><h5 id="2-5-import命令具有提升效果，会提升到整个模块的头部，首先执行"><a href="#2-5-import命令具有提升效果，会提升到整个模块的头部，首先执行" class="headerlink" title="2.5 import命令具有提升效果，会提升到整个模块的头部，首先执行"></a>2.5 import命令具有提升效果，会提升到整个模块的头部，首先执行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"></span><br><span class="line">import &#123; foo &#125; from &apos;my_module&apos;;</span><br></pre></td></tr></table></figure><p>⚠️<span class="text-important">ES6模块是编译时加载，因此在import是静态执行，不可以使用变量，表达式。动态加载使用import()</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">import &#123; &apos;f&apos; + &apos;oo&apos; &#125; from &apos;my_module&apos;;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">let module = &apos;my_module&apos;;</span><br><span class="line">import &#123; foo &#125; from module;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">if (x === 1) &#123;</span><br><span class="line">  import &#123; foo &#125; from &apos;module1&apos;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  import &#123; foo &#125; from &apos;module2&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考资料：《ECMAScript 6 入门》阮一峰译（<a href="http://es6.ruanyifeng.com）" target="_blank" rel="noopener">http://es6.ruanyifeng.com）</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#ES6基础知识点&lt;br&gt;JavaScript的组成：ECMAScript（核心）、DOM（文档对象模型）、BOM （浏览器对象模型）&lt;br&gt;ECMAScript，规定了语言的组成部分：语法、类型、语句、关键字、保留字、操作符、对象。我们现在使用的是ES5，也就是ECMAS
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue源码分析-组件化-异步组件</title>
    <link href="http://yoursite.com/2019/02/02/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%BB%84%E4%BB%B6%E5%8C%96-%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/02/02/vue源码分析-组件化-异步组件/</id>
    <published>2019-02-02T04:55:27.000Z</published>
    <updated>2019-02-02T10:03:19.009Z</updated>
    
    <content type="html"><![CDATA[<p>异步组件，一般用于按需加载。对于一些需要优化首屏加载的，会减少首屏的包体积，一般会将一些首屏组件变成异步组件。异步组件的实现方式有三种：工厂函数，promise异步组件，高级异步组件。<br><a id="more"></a></p><h3 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;AysnComponent&apos;, function (resolve, reject) &#123;</span><br><span class="line">// 这个特殊的require语法会告诉webpack，自动将编译后的代码分割成不同的块，这些块会通过Ajax请求加载</span><br><span class="line">require([&apos;./components/AysnComponent&apos;], (res) =&gt; &#123;</span><br><span class="line">resolve(res)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在定义组件时，使用Vue.component时，第二个参数传递的是一个对象。在这里，定义异步组件的时候，第二个参数传递的是一个函数。<br>在vue的源码中，会判断传递的第二个参数是否是一个普通的对象，如果是，则会使用<strong>extend</strong>来创建一个Ctor构造函数。如果不是，则直接将传递的参数挂载在Vue.options.components.AysnComponent（其中的AynsComponent就是定义的名称），通过resolveAsset来创建一个Ctor，这里的Ctor其实就是一个工厂函数（也就是我们传递进去的函数），通过函数resolveAyscComponent(Ctor, baseCtor, context)「其实，Ctor就是我们传递的函数，baseCtor就是Vue，context当前组件的实例vm」</p><p>———————————————————————— 华丽的分割线 —————————————————————<br><br>「扩展 1 」：once，方法只执行一次的实现方式？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function once (fn: Function): Function &#123;</span><br><span class="line">let called = true</span><br><span class="line">return function () &#123;</span><br><span class="line">if (!called) &#123;</span><br><span class="line">called = false</span><br><span class="line">fn.apply(this, arguments)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;异步组件，一般用于按需加载。对于一些需要优化首屏加载的，会减少首屏的包体积，一般会将一些首屏组件变成异步组件。异步组件的实现方式有三种：工厂函数，promise异步组件，高级异步组件。&lt;br&gt;
    
    </summary>
    
      <category term="vue源码分析" scheme="http://yoursite.com/categories/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>electron学习</title>
    <link href="http://yoursite.com/2018/11/26/electron%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/11/26/electron学习/</id>
    <published>2018-11-26T05:53:43.000Z</published>
    <updated>2018-11-26T05:57:16.175Z</updated>
    
    <content type="html"><![CDATA[<ol><li>使用vue-electron脚手架时，electron-builder与electron-packager的区别（参考文档：<a href="https://github.com/ielectron-userland/electron-builder与https://github.com/ielectron-userland/electron-packager）" target="_blank" rel="noopener">https://github.com/ielectron-userland/electron-builder与https://github.com/ielectron-userland/electron-packager）</a></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;使用vue-electron脚手架时，electron-builder与electron-packager的区别（参考文档：&lt;a href=&quot;https://github.com/ielectron-userland/electron-builder与https
      
    
    </summary>
    
      <category term="Electron" scheme="http://yoursite.com/categories/Electron/"/>
    
    
  </entry>
  
  <entry>
    <title>XHR对象</title>
    <link href="http://yoursite.com/2018/11/06/XHR%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/11/06/XHR对象/</id>
    <published>2018-11-06T09:55:10.000Z</published>
    <updated>2018-11-26T05:54:32.258Z</updated>
    
    <content type="html"><![CDATA[<p>XHR其实就是XMLHttpRequest对象，也就是Ajax的核心技术。XHR为向服务器发送请求以及解析服务器响应提供了接口，能够以异步的方式从服务器获取信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;XHR其实就是XMLHttpRequest对象，也就是Ajax的核心技术。XHR为向服务器发送请求以及解析服务器响应提供了接口，能够以异步的方式从服务器获取信息。&lt;/p&gt;

      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>客户端数据存储</title>
    <link href="http://yoursite.com/2018/10/29/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    <id>http://yoursite.com/2018/10/29/客户端数据存储/</id>
    <published>2018-10-29T11:35:32.000Z</published>
    <updated>2018-10-31T09:38:36.134Z</updated>
    
    <content type="html"><![CDATA[<p>常见的客户端数据存储：Cookie，Web Storage。其中Web Storage主要包含localStorage，sessionStorage，globalStorage这三种，Web Storage规范出现主要是为了提供一种除了cookie之外的会话存储的途径，以及一种可以存储大量可以跨会话存在的数据的机制。Cookie也叫做HTTP Cookie，最初在客户端是用于存储会话信息的。👓👌咳咳，接下来，我们深入的了解一下Cookie以及Web Storage吧～～～<br><a id="more"></a></p><h4 id="1-Cookie"><a href="#1-Cookie" class="headerlink" title="1. Cookie"></a>1. Cookie</h4><p>Cookie也就是HTTP Cookie，最初在客户端用于存储会话信息，设置完cookie后，在指定的域地址中，请求中带有cookie的信息（Request Headers中就会包含cookie），cookie的名和值在传送时是需要通过URL编码，否则会乱码。<br>该标准要求服务器对 任意 HTTP 请求发送 Set-Cookie HTTP 头作为响应的一部分，其中包含会话信息。浏览器会存储这样的会话信息，并在这之后，通过为每个请求添加 Cookie HTTP 头将信息发送回服务器。</p><h5 id="1-1-限制"><a href="#1-1-限制" class="headerlink" title="1.1 限制"></a>1.1 限制</h5><p>访问限制：在某个环境下设置了cookie，那么此cookie是绑定在此特定的域名下，以后再给创建它的域名发送请求时，都会包含这个cookie。这个让cookie只能在创建它的域名下被访问，其它环境不可以进行访问。<br>个数限制：不同浏览器下，每个域中所能包含的cookie个数也是有限的。当单个域名下的cookie数量超出限制后，浏览器会删除以前设置的cookie，但是IE与Opera会删除最少使用的cookie，FireFox是随机删除。<br>长度限制：cookie长度，在大多数浏览器下，大约是4096B的长度限制。这个长度限制是对每个域下的所有的cookie的总限制，而不是单个cookie的长度限制。超出长度限制，则浏览器会默默地将cookie丢掉。</p><h5 id="1-2-cookie构成"><a href="#1-2-cookie构成" class="headerlink" title="1.2 cookie构成"></a>1.2 cookie构成</h5><ol><li>名称name： cookie名称不区分大小写，相同字母，大小写不一样的，会被当成一个cookie。在实际中，最好定义以及后面使用的时候，要相同大小写相同字母，因为有些浏览器中cookie键值对需要进行URL编码。</li><li>值value： 对应cookie名称的值，是字符串，需要通过URL编码。</li><li>域domain： cookie的域限制，指定cookie在哪个域下被访问。</li><li>地址path： 指定域中的哪个路径，应该向服务器端发送cookie</li><li>失效时间expires： cookie被删除的时间戳。到达结束时间的时候，cookie会被删除。这个值要是GMT格式的日期(Wdy, DD-Mon-YYYY HH:MM:SS GMT)，如果设置的时间是在当前日期之前，则cookie会立马被删除。</li><li>安全标志secure： 指定之后，cookie只有在SSL连接的时候才能发送到服务器（也就是https中只能在https的域中，不能发送给同域名的http中）。是一个非键值对，就一个单独的secure单词标志。</li></ol><h5 id="1-3-cookie的操作"><a href="#1-3-cookie的操作" class="headerlink" title="1.3 cookie的操作"></a>1.3 cookie的操作</h5><p>在浏览器中，cookie是挂载在document上的。<br><strong>获取</strong>： 通过document.cookie来获取当前页面可用的cookie字符串（一个使用分号连接起来的键值对字符串），并且得到的所有的键值对都是经过URL编码的，所以需要通过decodeURIComponent来解码<br><strong>设置</strong>： document.cookie可以设置一个新的cookie字符串，这个cookie字符串会被解析并添加到现有的cookie集合中。设置document.cookie并不会覆盖掉原来的cookie，而是在原先的基础上添加（只有在设置的cookie名相同，则会覆盖掉原先设置的同名cookie的值）。在设置时，最好每次对键值对都进行一次encodeURIComponent编码，防止中文乱码情况<br><strong>删除</strong>：没有直接删除的方法，但是可以通过将有效时间设置成现在之前的时间，从而使得cookie删除</p><pre><code>const COOKIE_UTIL = {    get: (name) =&gt; {        var cookieName = encodeURIComponent(name) + &apos;=&apos;,             cookieStart = document.cookie.indexOf(cookieName),             cookieValue = &apos;&apos;;        if (cookieStart &gt; -1) {            var cookieEnd = document.cookie.indexOf(&apos;;&apos;, cookieStart);            cookieEnd = cookieEnd === -1 ? document.cookie.length : cookieEnd;            cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));        }        return cookieValue;         },    set: (name, value, expires, path, domain, secure) =&gt; {        var cookieText = encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value);        if (expires instanceof Date) {            cookieText += &apos;; expires=&apos; + expires.toGMTString();        }        if (path) {            cookieText += &apos;; path=&apos; + path;        }        if (domain) {            cookieText += &apos;; domain=&apos; + domain;        }        if (secure) {            cookieText += &apos;;secure&apos;;            }        document.cookie = cookieText;    },    unset: (name, path, domain, secure) =&gt; {        this.set(name, &quot;&quot;, new Date(0), path, domain, secure);    }};</code></pre><h4 id="2-Web-Storage"><a href="#2-Web-Storage" class="headerlink" title="2. Web Storage"></a>2. Web Storage</h4><p>Web Storage是一个标准，包含了sessionStorage，localStorage，globalStorage对象，都是直接挂载于window对象上的。</p><h5 id="2-1-Storage类型"><a href="#2-1-Storage类型" class="headerlink" title="2.1 Storage类型"></a>2.1 Storage类型</h5><p>Storage实例有如下几个方法：<br><strong>1. 增</strong> getItem(name) 指定名称name获取对应的值；key(index) 获取index处的名称<br><strong>2. 删</strong> clear() 删除所有的值； 直接使用对象的删除 delete<br><strong>3. 改</strong> setItem(name, value) 为指定name设置一个对应的值<br><strong>4. 查</strong> getItem(name) 获取指定name的值<br>属性：length ==&gt; Storage实例中含有几对键值对</p><h5 id="2-2-sessionStorage对象"><a href="#2-2-sessionStorage对象" class="headerlink" title="2.2 sessionStorage对象"></a>2.2 sessionStorage对象</h5><p>sessionStorage是用于特定会话中存储数据，并且数据只保留到<span class="font-color-red">浏览器关闭</span>。存储在 sessionStorage 中的数据只能由最初给对象存储数据的页面访问到，所以对多页面应用有限制。Storage实例含有的方法和属性，sessionStorage也拥有。<br><strong>范围限制</strong>：要访问同一个localStorage，需要在同一协议，同一域名，同一端口号的页面。<br><strong>存储时间</strong>：一直保留到浏览器关闭。</p><h5 id="2-3-localStorage对象"><a href="#2-3-localStorage对象" class="headerlink" title="2.3 localStorage对象"></a>2.3 localStorage对象</h5><p>localStorage是在修订后的HTML5规范中取代了globalStorage。localStorage是Storage实例，因此拥有Storage类型的所有方法以及属性。<br><strong>范围限制</strong>：要访问同一个localStorage，需要在同一协议，同一域名，同一端口号的页面。<br><strong>存储时间</strong>：一直保留到主动使用方法删除或者用户清除浏览器缓存。</p><h5 id="2-4-globalStorage对象"><a href="#2-4-globalStorage对象" class="headerlink" title="2.4 globalStorage对象"></a>2.4 globalStorage对象</h5><p>globalStorage主要目的是为了跨域会话，但是也有特定的限制。在使用globalStorage，首先要指定哪些区域可以访问该数据，可以通过方括号标记使用属性来实现。<br>eg: globalStorage[‘my.com’].name = ‘zhaoshijuan’<br>这里访问的globalStorage[‘my.com’]是针对域名‘my.com’的存储空间<br>⚠️ globalStorage不是Storage实例，而上面的globalStorage[‘my.com’]才是Storage对象，因此拥有Storage上的方法以及属性的是globalStorage[‘my.com’]这个对象。<br>globalStorage[‘’].name = ‘zhaoshijuan’，这个设置是对任何人都看见，没有域限制。<br>globalStorage[‘net’].name = ‘zhaoshijuan’，这个设置会让所有以.net结束的域名访问。<br>在不确定域名时，可以通过这样设置：globalStorage[‘location.host’].name = ‘zhaoshijuan’<br><strong>范围限制</strong>：根据globalStorage后[]括号而定。<br><strong>存储时间</strong>：如果没有使用removeItem或者delete删除，会一直保留到用户删除浏览器缓存为止。</p><blockquote><p>Stroge对象中存储的都是字符串</p></blockquote><h5 id="2-5-Storage事件"><a href="#2-5-Storage事件" class="headerlink" title="2.5 Storage事件"></a>2.5 Storage事件</h5><p>对Storage对象进行的修改，都会触发storage事件，storage事件是绑定在document上的。storage事件event对象含有如下几个属性：<br>domain：发生变化的存储空间的域名<br>key：变化的键名<br>newValue：修改值，则是新值；删除值，则是undefined<br>oldValue：键对应值被修改之前的值</p><p>addEventListener(document, ‘storage’, function(event) {})</p><h4 id="3-Cookie与Web-Storage对比"><a href="#3-Cookie与Web-Storage对比" class="headerlink" title="3. Cookie与Web Storage对比"></a>3. Cookie与Web Storage对比</h4><h5 id="3-1-区别"><a href="#3-1-区别" class="headerlink" title="3.1 区别"></a>3.1 区别</h5><ol><li>存储内容是否发送到服务器端：当设置了Cookie后，数据会发送到服务器端，造成一定的宽带浪费； web storage,会将数据保存到本地，不会造成宽带浪费；</li><li>数据存储大小不同：Cookie数据不能超过4K,适用于会话标识；web storage数据存储可以达到5M;</li><li>数据存储的有效期限不同：cookie只在设置了Cookid过期时间之前一直有效，即使关闭窗口或者浏览器；sessionStorage,仅在关闭浏览器之前有效；localStorage,数据存储永久有效；</li><li>作用域不同：cookie和localStorage是在同源同窗口中都是共享的；sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；</li></ol><h5 id="3-2-Web-Storage相比Cookie的优势"><a href="#3-2-Web-Storage相比Cookie的优势" class="headerlink" title="3.2 Web Storage相比Cookie的优势"></a>3.2 Web Storage相比Cookie的优势</h5><ol><li>存储空间更大：IE8下每个独立的存储空间为10M，其他浏览器实现略有不同，但都比Cookie要大很多。</li><li>存储内容不会发送到服务器：当设置了Cookie后，Cookie的内容会随着请求一并发送的服务器，这对于本地存储的数据是一种带宽浪费。而Web Storage中的数据则仅仅是存在本地，不会与服务器发生任何交互。</li><li>更多丰富易用的接口：Web Storage提供了一套更为丰富的接口，如setItem,getItem,removeItem,clear等,使得数据操作更为简便。cookie需要自己封装。</li><li>独立的存储空间：每个域（包括子域）有独立的存储空间，各个存储空间是完全独立的，因此不会造成数据混乱。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常见的客户端数据存储：Cookie，Web Storage。其中Web Storage主要包含localStorage，sessionStorage，globalStorage这三种，Web Storage规范出现主要是为了提供一种除了cookie之外的会话存储的途径，以及一种可以存储大量可以跨会话存在的数据的机制。Cookie也叫做HTTP Cookie，最初在客户端是用于存储会话信息的。👓👌咳咳，接下来，我们深入的了解一下Cookie以及Web Storage吧～～～&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>Function对象</title>
    <link href="http://yoursite.com/2018/10/26/Function%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/10/26/Function对象/</id>
    <published>2018-10-26T06:18:11.000Z</published>
    <updated>2018-10-29T09:44:33.098Z</updated>
    
    <content type="html"><![CDATA[<p>每次看源码或者找一些求最大值最小值简便方法时，就会遇见call(),apply()这两个方法，当时的理解就是：设置函数上下文，this指向。但是……理解得太片面了，正好有时间，就打算了解一下👏👏👏<br><a id="more"></a></p><h4 id="1-Function类型"><a href="#1-Function类型" class="headerlink" title="1. Function类型"></a>1. Function类型</h4><p>我们先了解一波Function这种引用类型吧～～～</p><h5 id="1-1-函数定义"><a href="#1-1-函数定义" class="headerlink" title="1.1 函数定义"></a>1.1 函数定义</h5><p>「1」函数声明语法 function fun () {}<br>「2」函数表达式定义  var fun = function () {}<br>「3」Function构造函数  var fun = new Function (‘params1’, ‘params2’, ‘return params1 + prams2’)</p><blockquote><p>不推荐使用Function构造函数定义，因为会导致两次解析：第一次是解析常规的js代码，第二次是解析传入构造函数中的字符串</p></blockquote><h6 id="1-2-函数内部的一些属性"><a href="#1-2-函数内部的一些属性" class="headerlink" title="1.2 函数内部的一些属性"></a>1.2 函数内部的一些属性</h6><p>每个函数内部都可以使用arguments来访问传入的所有的参数（是一个伪数组）；<br>arguments.callee是一个指针，指向拥有这个arguments对象的函数；<br>caller是函数对象的属性，保存着调用此函数的函数引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var inner = function() &#123; </span><br><span class="line">console.log(inner.caller); // outer</span><br><span class="line">// 等价于下面</span><br><span class="line">console.log(arguments.callee.caller)</span><br><span class="line">&#125;;</span><br><span class="line">var outer = function() &#123;</span><br><span class="line">inner();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果某函数在全局作用域下调用的话，则某函数的caller为null</p><h5 id="1-3-函数属性"><a href="#1-3-函数属性" class="headerlink" title="1.3 函数属性"></a>1.3 函数属性</h5><p>「1」长度length：表示的函数接受的命名参数的个数<br>「2」原型prototype：不可枚举，保存了所有实例方法</p><h4 id="2-函数内部非继承方法：apply，call，bind"><a href="#2-函数内部非继承方法：apply，call，bind" class="headerlink" title="2. 函数内部非继承方法：apply，call，bind"></a>2. 函数内部非继承方法：apply，call，bind</h4><p>apply，call，bind三个方法都是指定在特定作用域内调用此函数，实际上相当于设置了此函数内的this对象的值</p><h5 id="2-1-apply"><a href="#2-1-apply" class="headerlink" title="2.1 apply"></a>2.1 apply</h5><p>apply（作用域，数组类型参数）<br>两个参数：一个在其中运行的函数的作用域，一个是参数数组（arguments或者Array实例）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function sum (num1, num2) &#123;</span><br><span class="line">return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">function applySum (num1, num2) &#123;</span><br><span class="line">return sum.apply(this, arguments);</span><br><span class="line">&#125;</span><br><span class="line">function applySum1 (num1, num2) &#123;</span><br><span class="line">return sum.apply(this, [num1, num2]);</span><br><span class="line">&#125;</span><br><span class="line">applySum(10, 10); // 20</span><br><span class="line">applySum1(10, 10); // 20</span><br></pre></td></tr></table></figure><h5 id="2-2-call"><a href="#2-2-call" class="headerlink" title="2.2 call"></a>2.2 call</h5><p>call（作用域，参数1，参数2，……，参数N）<br>两类参数：一类也就是第一个参数在其中运行的函数的作用域；另一类也就是参数，是直接传递给函数的参数，传递给函数的参数必须逐一列举出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sum (num1, num2) &#123;</span><br><span class="line">return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">function callSum (num1, num2) &#123;</span><br><span class="line">return sum.call(this, num1, num2)</span><br><span class="line">&#125;</span><br><span class="line">callSum(10 ,10)// 20</span><br></pre></td></tr></table></figure><h5 id="2-3-bind-IE9"><a href="#2-3-bind-IE9" class="headerlink" title="2.3 bind   IE9+"></a>2.3 bind   <span class="font-color-red">IE9+</span></h5><p>bind()这个方法会创建一个函数的实例，其this的值会被绑定到传给bind()函数的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.color = &apos;red&apos;;</span><br><span class="line">var object = &#123; color: &apos;blue&apos; &#125;;</span><br><span class="line">function getColor () &#123;</span><br><span class="line">return this.color;</span><br><span class="line">&#125;</span><br><span class="line">var getColor1 = getColor.bind(object);</span><br><span class="line">getColor1(); // blue</span><br></pre></td></tr></table></figure><h5 id="2-4-apply、call、bind区别"><a href="#2-4-apply、call、bind区别" class="headerlink" title="2.4 apply、call、bind区别"></a>2.4 apply、call、bind区别</h5><p>call,apply,bind作用：扩大了函数赖以运行的作用域。<br>对于call，apply的第一个参数如果指定成null或者undefined的时候，则此时的this就会指向全局环境。</p><p>「1」call，apply区别主要在于传参，除了指定作用域的参数外，call的其他参数主要是直接传递给函数的参数，需要一一列举；而apply的其他参数是一个参数数组（arguments或者Array实例）。其实就是参数格式不一样。<br>「2」bind与call，apply的区别主要是call，apply不会生成一个函数，而是直接传递作用域；而bind则是使用传入的作用域绑定this创建一个函数的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1, 2, 3, 4, 5, 6, 7];</span><br><span class="line">var max1 = Math.max.apply(null, numbers);</span><br><span class="line">// 等价于下面</span><br><span class="line">var max2 = Math.max.call(null, ...numbers);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每次看源码或者找一些求最大值最小值简便方法时，就会遇见call(),apply()这两个方法，当时的理解就是：设置函数上下文，this指向。但是……理解得太片面了，正好有时间，就打算了解一下👏👏👏&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>Array数组之旅</title>
    <link href="http://yoursite.com/2018/10/23/Array%E6%95%B0%E7%BB%84%E4%B9%8B%E6%97%85/"/>
    <id>http://yoursite.com/2018/10/23/Array数组之旅/</id>
    <published>2018-10-23T07:01:41.000Z</published>
    <updated>2018-10-31T09:55:10.166Z</updated>
    
    <content type="html"><![CDATA[<p>要学习ES6中的数组扩展篇章，所以就先去预习了一波原本接触到的Array。所谓温故而知新嘛~~<br>首先我们先了解一下js中的对象：1.内部对象，内部对象包含下面三种：错误对象（标识错误），内置对象（不需要使用new操作符来进行初始化，Math与JSON两种），常用对象（8种，String、Number、Date、Function、Boolean、Array、Object、RegExp）；2.宿主对象，宿主对象主要有两个window与document。3.自定义对象，除了内部对象以及宿主对象之外，其它都为自定义对象，也就是开发者自己定义的对象。<br>说起Array，能想到的就是属性length，方法push，pop，reverse，shift，unshift，jion，slice，splice……等方法<br>推荐喜马拉雅上的「陪你读书（JavaScript WEB 编程）」的课程~~~<br><a id="more"></a></p><p>基础数据类型：Number、undefined、null、Boolean、String、symbol<br>复杂类型：Object<br>typeOf(null) === ‘Object’<br>js解释器，会将其进行解释，转化成二进制，默认前三位是0的就是Object类型。而null转化成二进制的时候，会变成所有位置上全是0。</p><h3 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a>Array数组</h3><p>是一个有序的合集。对象是无序的合集，对于有序的对象称作为数组。数组里面可以包含任何数据类型，数组大小可以调整。</p><h4 id="1-创建数组"><a href="#1-创建数组" class="headerlink" title="1. 创建数组"></a>1. 创建数组</h4><p>new关键字 new Array(参数),其中参数只是一个数字的话，则创建出来的是一个指定长度的数组，里面的每项都是undefined。不要使用多个逗号进行创建数组<br>字面量    [array1, array2]</p><h4 id="2-方法"><a href="#2-方法" class="headerlink" title="2. 方法"></a>2. 方法</h4><h5 id="2-1-读写"><a href="#2-1-读写" class="headerlink" title="2.1 读写"></a>2.1 读写</h5><p>读取arr[index]；写arr[index] = 1；<br>删除delete arr[index],数组长度不会变化，但是在index位置上的数据就是undefined</p><h5 id="2-2-判断是否是数组类型"><a href="#2-2-判断是否是数组类型" class="headerlink" title="2.2 判断是否是数组类型"></a>2.2 判断是否是数组类型</h5><ol><li>instanceof  arr instanceof Array</li><li>原型构造函数 arr.<strong> proto </strong>.constructor === Array</li><li>Object.prototype.toString.call(arr) == ‘[object Array]’</li><li>ES6中的isArray方法  Array.isArray(arr)</li></ol><h5 id="2-3-变异方法"><a href="#2-3-变异方法" class="headerlink" title="2.3 变异方法"></a>2.3 变异方法</h5><p>变异方法，在Vue中包含，它们会触发视图更新<br>栈方法：push,pop在数组的末端进行添加或者删除，返回值push是数组的长度pop是弹出的那一项，对数组造成影响<br>队列方法：unshift,shift在数组的首端进行添加或者删除，返回值unshift是数组的长度shift是弹出的那一项，对数组造成影响<br>排序：sort 按照字符串的ASII码进行排序。（fn(a,b){}）按照fn方法排序，a-b从小到大，b-a从大到小<br>反转：reverse<br>删除，截取，替换：splice(index,num,item) index是添加/删除的位置，负数就是从后往前；num是删除的数量；item是在index位置上添加的新内容</p><h5 id="2-4-非变异方法"><a href="#2-4-非变异方法" class="headerlink" title="2.4 非变异方法"></a>2.4 非变异方法</h5><p>对于非变异的，则不会触发视图更新，需要使用vm.$set或者Vue.set方法<br>截取：slice（start,end）返回的是从start开始，end结束的截取的子数组。start，end可以为负数，表示从数组末端到开始。start，end都没有，则截取整个数组；只有start，从start开始到结束截取；有start，end，截取start至end。<br>转为字符串：join(separator) 将数组转化为字符串，中间使用separator分隔开。<br>连接数组：concat(arr1,……,arrn) 连接两个或者多个数组，返回的是一个数组。</p><blockquote><p>扩展：push与concat的区别，同样：都是连接作用。不同：push会影响数组，concat不影响；如果参数是一个数组，push只会增加一项，直接将数组作为它最新的一项，会变成一个二维数组，concat的话，直接将数组一个一个的添加到原来的数组上，还是一个一维数组。</p></blockquote><h5 id="2-5-ES5的indexOf与lastIndexOf"><a href="#2-5-ES5的indexOf与lastIndexOf" class="headerlink" title="2.5 ES5的indexOf与lastIndexOf"></a>2.5 ES5的indexOf与lastIndexOf</h5><p>arr.indexOf(item) 返回item在arr数组中从左到右的index，有返回index，没有返回-1<br>arr.lastIndexOf(item) 返回item在arr数组中从右到左的index，有返回index，没有返回-1</p><h5 id="2-6-其它一些不常用常见的方法"><a href="#2-6-其它一些不常用常见的方法" class="headerlink" title="2.6 其它一些不常用常见的方法"></a>2.6 其它一些不常用常见的方法</h5><ol><li>every</li><li>fill</li><li>filter</li><li>forEach</li><li>Map</li><li>reduce</li><li>reduceRight</li></ol><h4 id="3-ES6-数组扩展"><a href="#3-ES6-数组扩展" class="headerlink" title="3. ES6 数组扩展"></a>3. ES6 数组扩展</h4><h5 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h5><h4 id="4-数组应用"><a href="#4-数组应用" class="headerlink" title="4. 数组应用"></a>4. 数组应用</h4><h5 id="4-1-数组去重"><a href="#4-1-数组去重" class="headerlink" title="4.1 数组去重"></a>4.1 数组去重</h5><p>方法一：循环去重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法二：ES6中的set数据类型<br>Set它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const set = new Set([1, 2, 3, 4, 4]);</span><br><span class="line">[...set]或者new Array(...set) // [1,2,3,4]</span><br></pre></td></tr></table></figure><p>方法三：数组存放，indexOf判断<br>遍历新数组，不存在就push进新数组中，存在就跳过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.unique = function() &#123;</span><br><span class="line">    var n = []; // 存放已遍历的满足条件的元素</span><br><span class="line">    for (var i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">        // indexOf()判断当前元素是否已存在</span><br><span class="line">        if (n.indexOf(this[i]) == -1) &#123;</span><br><span class="line">        n.push(this[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法四：对象存放，哈希算法(映射)判断<br>遍历新数组，不存在就push进新数组中，存在就跳过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.unique = function() &#123;</span><br><span class="line">    // n为hash表，r为临时数组</span><br><span class="line">    var n = &#123;&#125;, r = [];</span><br><span class="line">    for (var i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">        // 如果hash表中没有当前项</span><br><span class="line">        if (!n[this[i]]) &#123;</span><br><span class="line">            // 存入hash表</span><br><span class="line">            n[this[i]] = true;</span><br><span class="line">            // 把当前数组的当前项push到临时数组里面</span><br><span class="line">            r.push(this[i]); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法五：现排序，后比较</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.unique = function() &#123;</span><br><span class="line">    this.sort();</span><br><span class="line">    var re = [this[0]];</span><br><span class="line">    for (var i = 1; i &lt; this.length; i++) &#123;</span><br><span class="line">        if (this[i] !== re[re.length - 1]) &#123;</span><br><span class="line">            re.push(this[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-数组拍平"><a href="#4-2-数组拍平" class="headerlink" title="4.2 数组拍平"></a>4.2 数组拍平</h5><p>方法一：只适合二维数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.concat.apply([],arr)</span><br></pre></td></tr></table></figure><p>方法二：ES6的Generator函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, [[2, 3], 4], [5, 6]];</span><br><span class="line">var arrCopy = [];</span><br><span class="line"></span><br><span class="line">var flat = function* (a) &#123;</span><br><span class="line">  var length = a.length;</span><br><span class="line">  for (var i = 0; i &lt; length; i++) &#123;</span><br><span class="line">    var item = a[i];</span><br><span class="line">    if (Object.prototype.toString.call(item) == &apos;[object Array]&apos;) &#123;</span><br><span class="line">      yield* flat(item);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      yield item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for (var f of flat(arr)) &#123;</span><br><span class="line">  arrCopy.push(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要学习ES6中的数组扩展篇章，所以就先去预习了一波原本接触到的Array。所谓温故而知新嘛~~&lt;br&gt;首先我们先了解一下js中的对象：1.内部对象，内部对象包含下面三种：错误对象（标识错误），内置对象（不需要使用new操作符来进行初始化，Math与JSON两种），常用对象（8种，String、Number、Date、Function、Boolean、Array、Object、RegExp）；2.宿主对象，宿主对象主要有两个window与document。3.自定义对象，除了内部对象以及宿主对象之外，其它都为自定义对象，也就是开发者自己定义的对象。&lt;br&gt;说起Array，能想到的就是属性length，方法push，pop，reverse，shift，unshift，jion，slice，splice……等方法&lt;br&gt;推荐喜马拉雅上的「陪你读书（JavaScript WEB 编程）」的课程~~~&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>vue源码分析-组件化</title>
    <link href="http://yoursite.com/2018/10/15/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    <id>http://yoursite.com/2018/10/15/vue源码分析-组件化/</id>
    <published>2018-10-15T13:39:06.000Z</published>
    <updated>2019-02-02T04:50:17.227Z</updated>
    
    <content type="html"><![CDATA[<p>终于弄懂了定义一个vue实例到渲染成页面DOM的整个过程，心情炒鸡棒，今天打算开始了解一下vue的另外一个核心思想 — <strong>组件化</strong>。<br>所谓组件化，也就是将页面根据一些规则（业务/逻辑等）划分成一个个组件（Component），每个组件的css,js,模版,图片等资源都相互独立，每个组件的资源都放在一起开发维护。这样便于维护以及实现可复用～～～<br><a id="more"></a></p><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p><span class="text-important">组件的 vnode 是没有 children 的</span></p><h4 id="1-createComponent"><a href="#1-createComponent" class="headerlink" title="1. createComponent"></a>1. createComponent</h4><p>组件的创建最开始走的和<a href="../../../../2018/10/09/vue源码分析-数据驱动/#more">vue源码分析-数据驱动</a>章节的流程是一样的。也是，new Vue() ==&gt; this._init() ==&gt; initMixin() ==&gt; $mount() ==&gt; mountComponent() ==&gt; _render() ==&gt; $createElement ==&gt; createElement() ==&gt; _createElement()<br>但是，在_createElement()方法中，有一个判断，与之前的不一样<span class="font-color-red">if (typeof tag === ‘string’)</span><br><img src="createElement.png" alt="判断">在<a href="../../../../2018/10/09/vue源码分析-数据驱动/#more">vue源码分析-数据驱动</a>章节中，tag是一个‘div’满足，则直接进入判断中。此处是一个组件，tag则是一个对象<br><img src="tag_detail.png" alt="tag的详情">所以，直接进入createComponent方法中，并且传入了一系列的参数（tag,data,context,children）,其中只有tag以及context有值，并且context其实就是Vue。<br><img src="createComponent.png" alt="createComponent">其中context.$options._base其实就是Vue构造函数，Ctor就是tag，Ctor如果是对象的话，则会调用Vue.extend方法<br><img src="extend.png" alt="extend">extend方法主要是根据Vue构造函数创建一个Sub构造函数，并且在把传入的options和Vue上面原本挂载的options进行一个mergeOptions，将options内容进行合并，并且赋值给Sub.options，则当前组件就会含有自己的options，以及挂载在Vue上的全局component，directive，filter<br>其中，validateComponentName是用来检验组件名称是否合法合理。<br>sub构造函数中含有this. _ init()其实也就是上一章节中 _ init方法。<br>因此后期就会再次进入 _ init方法创建组件，直接进入initInternalComponent方法中，在initInternalComponent方法中，就是一系统的赋值等。</p><h4 id="2-patch"><a href="#2-patch" class="headerlink" title="2. patch"></a>2. patch</h4><p>在上面createComponent之后，进入createComponent方法中<br><img src="createComponent2.png" alt="createComponent2"><br>其中有一个installComponentHooks的方法，hooksToMerge其实就是一个对象，含有init，prepatch,insert,destory这四个字符串，通过便利，给data上添加上钩子函数（hook）<br><img src="installComponentHooks.png" alt="installComponentHooks"><br>将componentVNodeHooks对象中的相应的钩子函数赋值给data。<br>接着执行createComponent里面的方法new VNode，返回一个vnode<br>执行另外一个createComponent方法，调用原本赋值再vnode上的hook函数，将i的init方法赋值给i，再调用i方法<br><img src="createComponent3.png" alt="createComponent3"><br>进入原本hooksToMerge对象赋值给data上的init方法，通过createComponentInstanceForVnode函数创建组件对象<br><img src="componentVNodeHooks-init&amp;prepatch.png" alt="componentVNodeHooks-init&amp;prepatch"><br>在createComponentInstanceForVnode函数中，最终返回<span class="text-important">new vnode.componentOptions.Ctor(options)</span>，而vnode.componentOptions.Cto也就是我们在1. createComponent中利用Vue构造函数创建的一个Sub构造函数<br><img src="createComponentInstanceForVnode.png" alt="createComponentInstanceForVnode"><br>再次回到sub构造函数中，调用了this. _ init方法，其实也就是我们在<a href="../../../../2018/10/09/vue源码分析-数据驱动/#more">vue源码分析-数据驱动</a>章节中new Vue()后立马执行的初始化<br><img src="sub.png" alt="sub"><br>再次进入vue.prototype. _ init方法中，此时由于是组件，会调用initInternalComponent(vm, options);方法，而此时的没有el这个属性值没有值，则就不会去执行vm.$mount(vm.$options.el);<br>在initInternalComponent方法中，进行了一系列的赋值。其中注意：opts._parentVnode = parentVnode，则组件对象上的_parentVnode是一个占位node<br><img src="initInternalComponent.png" alt="initInternalComponent"><br>继续回到componentVNodeHooks中，调用child.$mount方法进行挂载，调用mountComponent，在mountComponent函数中定义 updateComponent = function () { vm._update(vm._render(), hydrating); }; 走起<a href="../../../../2018/10/09/vue源码分析-数据驱动/#more">vue源码分析-数据驱动</a>章节的流程（_render() ==&gt; $createElement ==&gt; createElement ==&gt; _createElement ==&gt; ）里层的元素组件进行上面的流程</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于弄懂了定义一个vue实例到渲染成页面DOM的整个过程，心情炒鸡棒，今天打算开始了解一下vue的另外一个核心思想 — &lt;strong&gt;组件化&lt;/strong&gt;。&lt;br&gt;所谓组件化，也就是将页面根据一些规则（业务/逻辑等）划分成一个个组件（Component），每个组件的css,js,模版,图片等资源都相互独立，每个组件的资源都放在一起开发维护。这样便于维护以及实现可复用～～～&lt;br&gt;
    
    </summary>
    
      <category term="vue源码分析" scheme="http://yoursite.com/categories/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript - 数据存储</title>
    <link href="http://yoursite.com/2018/10/10/JavaScript-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    <id>http://yoursite.com/2018/10/10/JavaScript-数据存储/</id>
    <published>2018-10-10T03:09:21.000Z</published>
    <updated>2018-10-29T09:44:03.165Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来都知道cookie、sessionStorage、localStorage这些用于缓存数据的,但并没有正式地去了解研究过它们，此次项目中用到这些知识，正好学习一波～<br>cookie：也就是HTTP cookie，客户端用于存储会话信息，是一个标准，并且要求服务器对任意HTTP请求发送Set-Cookie HTTP头作为响应的一部分。<br>Web Storage：一种为了存储大量可以跨会话存在的数据，新途径的标准。包含两种对象定义：sessionStorage、globalStorage……<br><a id="more"></a></p><h3 id="1-cookie"><a href="#1-cookie" class="headerlink" title="1. cookie"></a>1. cookie</h3><h3 id="2-Web-Storage"><a href="#2-Web-Storage" class="headerlink" title="2. Web Storage"></a>2. Web Storage</h3><h4 id="2-1-sessionStorage"><a href="#2-1-sessionStorage" class="headerlink" title="2.1 sessionStorage"></a>2.1 sessionStorage</h4><h4 id="2-2-globalStorage"><a href="#2-2-globalStorage" class="headerlink" title="2.2 globalStorage"></a>2.2 globalStorage</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来都知道cookie、sessionStorage、localStorage这些用于缓存数据的,但并没有正式地去了解研究过它们，此次项目中用到这些知识，正好学习一波～&lt;br&gt;cookie：也就是HTTP cookie，客户端用于存储会话信息，是一个标准，并且要求服务器对任意HTTP请求发送Set-Cookie HTTP头作为响应的一部分。&lt;br&gt;Web Storage：一种为了存储大量可以跨会话存在的数据，新途径的标准。包含两种对象定义：sessionStorage、globalStorage……&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>vue源码分析 - 数据驱动</title>
    <link href="http://yoursite.com/2018/10/09/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8/"/>
    <id>http://yoursite.com/2018/10/09/vue源码分析-数据驱动/</id>
    <published>2018-10-09T02:49:58.000Z</published>
    <updated>2019-02-02T04:50:51.888Z</updated>
    
    <content type="html"><![CDATA[<p>数据驱动是vue.js的一个重要的思想。数据驱动：视图根据数据驱动生成，我们不会通过直接修改dom来修改视图，会通过修改数据来完成对视图的修改。<br><a id="more"></a></p><blockquote><p>Runtime-only: 需要借助类似于webpack的vue-loader来将.vue文件编译成JavaScript。因为是在编译阶段做的，所以只包含运行时的Vue.js代码，代码体积更轻便。<br><br>Runtime + compiler: 没有对代码做预编译。因为在Vue.js2.0中，最后渲染都是通过render函数，如果编写了template，则需要编译成render函数，而这个编译过程发生在运行时，所以需要带有编译器的版本，并且这个编译过程对性能会有一定的损耗。</p></blockquote><h3 id="1-new"><a href="#1-new" class="headerlink" title="1. new"></a>1. new</h3><blockquote><p>new Vue()一个实例干了什么？</p></blockquote><p><img src="https://i.imgur.com/lny4o5V.png" alt="new vue时的代码"><br>new Vue()后只会判断使用的语法对不对，然后就调用已经挂载到Vue原型上的_init方法(通过initMixin(Vue))，在initMixin()之前，Vue上只有一个构造函数外加一个<strong>proto</strong>（也就是Object所含有的）。<br><img src="https://i.imgur.com/PNzomC5.png" alt="vue.prototype"></p><h3 id="2-init"><a href="#2-init" class="headerlink" title="2. init"></a>2. init</h3><p>initMixin方法在Vue.prototype上挂载了一个_init方法<br><img src="https://i.imgur.com/Yt9N7Rl.png" alt=""><br>在initMixin方法中：先将options进行整合（具体先不管）；<br>后又进行了一系统的初始化：生命周期初始化（initLifecycle）、事件初始化（initEvents）、渲染（initRender）、callHook()、初始化数据（initState）以及一些其它的初始化(initInjections、initProvide)</p><p>其中initState方法中含有initData方法(其中含有一个proxy(vm, “_data”, key)，为data中数据项进行一个代理设置)</p><p><img src="https://i.imgur.com/UHwd04N.png" alt=""><br>也就是利用了Object.defineProperty()方法来设置访问器属性，从而实现了直接修改类似this.message = 12也就是修改了this._data.message = 12</p><p>除了_data会使用proxy方法来进行一层设置代理，还会有_props，因此_data与_props里面定义的属性名称不能相同，不然就会出现覆盖的情况（写组件中经常就会遇见props中有一个a，data中也有一个a，则后期父组件修改a的值后，组件并不会跟着进行变化）</p><h3 id="3-mount"><a href="#3-mount" class="headerlink" title="3. $mount"></a>3. $mount</h3><p>在initMixin方法的最后根据vm.$options.el是否存在来决定是否挂载</p><p><code>if (vm.$options.el) {  vm.$mount(vm.$options.el);}</code></p><p>$mount方法是挂载在vue构造函数prototype上的，里面直接调用的是mountComponent方法，后期又定义了updateComponent函数（里面调用了vue上的 _update 方法， _update 方法中传递了vue的 _render 函数渲染出来的vnode以及hydrating），又新建了一个 <span style="color:red;">渲染watcher</span>(后期发生变化，进行更新的时候，会执行渲染watcher中的updateComponent方法，从而重新渲染了一次)</p><p><img src="$mount.png" alt="$mount"></p><p>该过程主要做了：对options.render进行一个判断，看看是否书写了render函数，如果没有写，则对template进行解析，(其中没有template的时候，会根据getOuterHTML来得到模版字符串)，然后会根据template进行编译（使用compileToFunction），编译得到render函数以及staticRenderFns静态render函数。因为vue只认render函数。<br><br>有了render函数之后，就会调用mount.call(this,el,hydrating)，这个mount函数其实就是vue.prototype.$mount。然后就会执行上面的过程（$mount）</p><h3 id="4-compile"><a href="#4-compile" class="headerlink" title="4. compile"></a>4. compile</h3><p>函数compileToFunction来进行编译，拿到render渲染函数以及staticRenderFns静态render函数</p><h3 id="5-render"><a href="#5-render" class="headerlink" title="5. render"></a>5. render</h3><p>_render方法是实例的一个私有方法，它用来把实例渲染成vnode（虚拟Node）。<br><img src="render.png" alt="_render"><br>vnode = render.call(vm. _renderProxy, vm.$createElement);<br>其中vm. _renderProxy是上下文，在生产环境下，就是vm实例，在开发环境下是一个Proxy实例。(会在init过程中有下面的代码)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">  initProxy(vm);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  vm._renderProxy = vm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$createElemt在initRender中定义，initRender函数在init中执行。在$createElement函数中调用了createElement方法，createElement方法会返回一个VNode</p><h3 id="6-vnode"><a href="#6-vnode" class="headerlink" title="6. vnode"></a>6. vnode</h3><p>产生的前提：浏览器中的DOM比较庞大，并且设计的比较复杂，频繁地去更新DOM，也会产生性能问题。Virtual DOM 使用js对象来描述DOM。<br>Virtual DOM除了数据结构的定义，映射到真实的DOM上，还需要经历VNode的create、diff、patch等过程。而Vue中的createElement就是VNode的create。</p><p><img src="createElement.png" alt="createElement"></p><p>createElement方法调用的是 _createElement方法，在 _createElement方法中，对children做了normalize处理（也就是将children变成一维数组，涉及到的方法有：normalizeChildren，normalizeArrayChildren，simpleNormalizeChildren）</p><h3 id="7-patch"><a href="#7-patch" class="headerlink" title="7. patch"></a>7. patch</h3><blockquote><p>通过 _render函数以及createElement函数拿到了VNode，如何渲染到真实DOM上呢？</p></blockquote><p>通过vue中 _update方法，将VNode渲染成真实的DOM，此方法会在两种情况下被调用：首次渲染，数据更新。</p><p><img src="update.png" alt="update"></p><p>其中，会走到vm.<strong> patch </strong> 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.__ patch __ = inBrowser ? patch : noop;</span><br></pre></td></tr></table></figure></p><p><br>在服务器端是没有DOM这个概念的，所以不在客户端中，则是不需要渲染成真实DOM的。<br>调用<strong>patch</strong>方法的时候，第一个参数是真实的DOM，第二个参数是我们得到的VNode。通过<strong>patch</strong>方法中的createElm将VNode挂载到真实的DOM上，(如果有子节点，则递归调用createElm，没有子节点，则直接创建一个DOM)，最后通过insert方法插入真实DOM中（里面分情况调用了insertBefore与appendChild）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据驱动是vue.js的一个重要的思想。数据驱动：视图根据数据驱动生成，我们不会通过直接修改dom来修改视图，会通过修改数据来完成对视图的修改。&lt;br&gt;
    
    </summary>
    
      <category term="vue源码分析" scheme="http://yoursite.com/categories/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Flow初识</title>
    <link href="http://yoursite.com/2018/10/06/Flow%E5%88%9D%E8%AF%86/"/>
    <id>http://yoursite.com/2018/10/06/Flow初识/</id>
    <published>2018-10-06T02:35:16.000Z</published>
    <updated>2018-10-29T09:43:14.759Z</updated>
    
    <content type="html"><![CDATA[<p>借助学习vue.js源码，在其过程中，认识到了Flow，该篇主要介绍一下最基本的Flow<br><a id="more"></a></p><h3 id="初识Flow"><a href="#初识Flow" class="headerlink" title="初识Flow"></a>初识Flow</h3><h4 id="1-是什么？"><a href="#1-是什么？" class="headerlink" title="1. 是什么？"></a>1. 是什么？</h4><p>Flow是一种静态类型检查工具，是一种工具。</p><blockquote><p>静态类型检查： 在编辑期间尽早发现（由类型引起的）bug，又不影响代码运行（不需要运行时动态检查类型）</p></blockquote><h4 id="2-Flow的工作方式"><a href="#2-Flow的工作方式" class="headerlink" title="2. Flow的工作方式"></a>2. Flow的工作方式</h4><h5 id="2-1-类型推断"><a href="#2-1-类型推断" class="headerlink" title="2.1 类型推断"></a>2.1 类型推断</h5><blockquote><p>通过变量使用上下文来推断出变量类型，然后根据这些推断来检查类型</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*@flow*/``</span><br><span class="line">function split(str) &#123;</span><br><span class="line">  return str.split(&apos; &apos;)</span><br><span class="line">&#125;</span><br><span class="line">split(11)</span><br></pre></td></tr></table></figure><p><span style="color:red;">会报错</span>：原因是我们期待的是字符串类型，但是传入的是数字类型</p><h5 id="2-2-类型注释"><a href="#2-2-类型注释" class="headerlink" title="2.2 类型注释"></a>2.2 类型注释</h5><blockquote><p>事先注释好我们期待的类型，Flow会基于这些注释来判断</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*@flow*/</span><br><span class="line"></span><br><span class="line">function add(x, y)&#123;</span><br><span class="line">  return x + y</span><br><span class="line">&#125;</span><br><span class="line">add(&apos;Hello&apos;, 11)</span><br></pre></td></tr></table></figure><p>上面的代码<span style="color:red;">不会报错</span>，Flow的检查不出来，因为‘+’可以用于字符串也可以用于数字<br>则，此时就需要使用类型注释（：）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*@flow*/</span><br><span class="line"></span><br><span class="line">function add(x: number, y: number): number &#123;</span><br><span class="line">  return x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(&apos;Hello&apos;, 11)</span><br></pre></td></tr></table></figure><ul><li>数组类型注释格式：Array&lt; T &gt;，T 表示数组中每项的数据类型</li><li>一个变量可能多个类型时，可以使用<span style="color:red;"> ‘|’ </span>来连接两种类型，表示或</li><li>若想任意类型<span style="color:red;"> T </span>可以为 null 或者 undefined，只需类似如下写成可以使用<span style="color:red;"> ?T </span>的格式即可</li></ul><hr><p>参考：<a href="https://flow.org/en/docs/getting-started/" target="_blank" rel="noopener">Flow官网</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;借助学习vue.js源码，在其过程中，认识到了Flow，该篇主要介绍一下最基本的Flow&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>vue源码解析</title>
    <link href="http://yoursite.com/2018/09/30/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/09/30/vue源码解析/</id>
    <published>2018-09-30T08:33:47.000Z</published>
    <updated>2019-02-02T04:51:14.299Z</updated>
    
    <content type="html"><![CDATA[<p>开始学习vue<br><a id="more"></a></p><h2 id="vue源码解析"><a href="#vue源码解析" class="headerlink" title="vue源码解析"></a>vue源码解析</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h3 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h3><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><h3 id="深入响应式原理"><a href="#深入响应式原理" class="headerlink" title="深入响应式原理"></a>深入响应式原理</h3><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始学习vue&lt;br&gt;
    
    </summary>
    
      <category term="vue源码分析" scheme="http://yoursite.com/categories/vue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
</feed>
